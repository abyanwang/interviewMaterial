[TOC]



## C++基础

### 1.引用和指针的区别

在C和C++中，指针一般指的是某块内存的**地址**，通过这个地址，我们可以寻址到这块内存；而引用是一个变量的**别名**，例如我们给小明起了个外号：明明，那我们说明明的时候，就是说小明。

对于指针来说，它是一个地址，这个地址是一个数值，那么就意味这个数值可以为0(空指针)，也可以为其他，即指针可以不指向任何东西。

而对于引用来说，他是一个外号，外号一定是“某个存在物体”的外号，所以引用不能为空，即不能存在空引用。

根据以上可知指针和引用的一个重要不同：**指针可以为空，引用不能为空。**这就意味着我们拿到一个引用的时候，是不需要判断引用是否为空的，而拿到一个指针的时候，我们则需要判断它是否为空。这点经常在判断函数参数是否有效的时候使用。
例如：

```cpp
void fun1(int *point)
{
     // 为了代码的稳健和安全，我们需要判断指针是否有效,通常做法是判断指针是否为
     // 空，其他的判断就需要根据函数的具体功能来判断了
     if(!point)
     {
        return;
     }
     // 函数实现
}

void fun2(int &refence)
{
     // 在这里，我们就不用担心refence是否为空
}
```


引用修饰函数参数还可以提高效率，例子如下：

```cpp
Class Object
{// 实现省略，只需要知道我们在这里声明了一个类，在下面我们要将这个类的对象作为
 // 函数参数类型来使用};
void fun1(Object obj)
{
     // 此函数声明中，obj是值传递，会产生一个临时对象
}
void fun2(Object &obj)
{
    // 我们不用检查obj是否为空，同时，使用引用传递，可以避免临时对象
}
```


我们根据前面的描述，还可以知道指针可以多次赋值，即在某时刻可以指向地址1，换个时候可以指向地址2，例如：

```cpp
int a = 0;
int b = 1;
int *point = NULL;
point = &a;     // 在某个时刻，指针可以指向a
point = &b;     // 换个时刻，指针可以指向b
```


而引用则不同，引用只能在初始化的时候就赋好值，之后就不能改变了，用外号的例子来说就是"明明"这个外号在出现的时候就是代指小明，之后“明明”这个外号就绑在小明身上了，它不能过段时间换成小暗的外号。代码如下：

```cpp
int xiaoming = 1;
int &refence_mingming = xiaoming;
int xiaoan = 2;
refence_mingming = xiaoan;           // error,引用不能换了
```



由以上可以，当我们需要某个是否指向为空的时候，我们就需要使用指针了，还有指向的对象需要变化的时候，我们也需要使用指针。其他地方一般推荐引用。

const修饰引用，使得引用不能够进行值的变化。

const修饰指针，有两种区别

```cpp
	int t = 10;
	int* const p = &t;
	int t1 = 11;
	p = &t1;//error
```

```cpp
    int t = 10;
	const int* p = &t;
	int t1 = 11;
	p = &t1;//true
```



### 2.new delete malloc free

malloc/free 

用来分配内存和释放内存。

new/delete

1. new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
3. new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。



### 3.vector和list的区别

vector为存储的对象分配一块连续的地址空间，因此对vector中的元素随机访问效率很高。在vector中插入或者删除某个元素，需要将现有元素进行复制，移动。如果vector中存储的对象很大，或者构造函数复杂，则在对现有元素进行拷贝时开销较大，因为拷贝对象要调用拷贝构造函数。对于简单的小对象，vector的效率优于list。vector在每次扩张容量的时候，将容量扩展2倍，这样对于小对象来说，效率是很高的。

list中的对象是**离散存储**的，随机访问某个元素需要遍历list。在list中插入元素，尤其是在首尾插入元素，效率很高，只需要改变元素的指针。



### 4.vector的内存分配机制

vector所有的内存相关问题都可以归结于它的内存增长策略。vector有一个特点就是：内存空间只会增长不会减少。vector有两个函数，一个是capacity()，返回对象缓冲区（vector维护的内存空间）实际申请的空间大小，另一个size()，返回当前对象缓冲区存储数据的个数。对于vector来说，capacity是永远大于等于size的，当capacity和size相等时，vector就会扩容，capacity变大。

比如说vector最常用的push_back操作，它的整个过程是怎么一个机制呢？这个问题经常在面试中出现。

这个问题其实很简单，在调用push_back时，若当前容量已经不能够放入新的元素（capacity=size），那么vector会重新申请一块内存，把之前的内存里的元素拷贝到新的内存当中，然后把push_back的元素拷贝到新的内存中，最后要析构原有的vector并释放原有的内存。所以说这个过程的效率是极低的，为了避免频繁的分配内存，C++每次申请内存都会成倍的增长，例如之前是4，那么重新申请后就是8，以此类推。



### 5.set map

set和map内部都是使用红黑树进行实现  log(n)

加了unordered修饰的都是O(1)



### 6.虚函数

函数重载一般是指多个函数共用一个名字，用不同传递参数的方式来实现多态。

而在父类和子类之间，两个类中有不同的函数实现而函数名相同的函数时就会出现问题，子类函数在逻辑上虽然会继承父类的函数，但是两个函数并不能通过不同的参数传递方式来进行区分(会报错)。而且在使用指针指向类时，父类指针指向子类实体时，调用的还是父类的函数实现。

这是需要通过加上virtual来实现继承中的函数多态。

```cpp
#include<bits/stdc++.h>
using namespace std;

class A{
	public:
		void cal(){
			cout<<"A cal"<<endl;
		}
}; 

class B:public A{
	public:
		void cal1(){
			cout<<"B cal"<<endl;
		}
};

int main(){
	A *b = new B();
	b->cal();
	return 0;
}
```

这里使用A类指针指向B类实体，调用的cal()函数是A类的。

- 在java中extend一个父类，在子类中写和父类同样的方法，使用效果和c++的虚函数相同。


**虚析构函数**，如果不加virtual的话，那么在类的析构函数的调用需要根据指针来进行判断，如果是父类的指针，那么可能少析构子类中的内存。

```cpp
#include <iostream>
using namespace std;
 
class Base
{
private:
	int i;
public :
	Base()
	{
		cout << "Base count " << endl;
	}
	 ~Base()
	{ 
		
		cout << " Base descount" << endl;
	}
};
class Inherit :public Base
{
private:
	int num;
public: 
	Inherit()
	{
		cout << "Inherit count" << endl;
	}
	 ~Inherit()  
	{
		cout << "Inherit descout" << endl;
		
	}
};
int main()
{
	Base *p =  new Inherit();
	delete p;
	Base *q = new Base();
	delete q;
	return 0;
}
```

此时第一个p就只会析构父类中的内存，而不会调用子类的析构函数。

讲虚函数表的文章: https://blog.twofei.com/496/



**虚继承**

避免菱形继承问题

```cpp
class A    // 声明基类A
{
    // 代码
};
class B: virtual public A    // 声明类 B 是类 A 的公有派生类，A 是 B 的虚基类
{
    // 代码
};
class C: virtual public A    // 声明类 C 是类 A 的公有派生类，A 是 C 的虚基类
{
    // 代码
};
class D: public B, public C    // 类 D 中只有一份 A 的数据
{
    // 代码
};
```



### 7.完全背包的推导

```cpp
# dp[i][j] 使用前i种硬币计算j分的表示法种数 令coins=[25, 10, 5, 1]
# dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
# j >= k*coins[i]
# dp[i][j-coins[i]] = dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
# dp[i][j] - dp[i][j-coins[i]] = dp[i-1][j]
# dp[i][j] = dp[i][j-coins[i]] + dp[i-1][j]

dp[j] = dp[j]+dp[j-coins[i]];
```

从0开始更新第i个的状态。已经更新的为f(i,j-coins[i]),加上本身还没有更新的自己f(i-1,j);



### 8.左闭右开的写法

二分查找中写成左闭右开，主要看left的操作，left为可以取到的，而二分查找尽量写成都越过mid，即都不取到mid。最后l==r，表示将整个空间都搜索完全。

而搜索中写成左闭右开需要考虑到只剩下一个元素时即返回。所以一般为l+1 >= r时return。

双指针写法时不考虑这些。

https://www.luogu.com.cn/blog/HOJQVFNA/qian-tan-er-fen-di-bian-jie-wen-ti

快速排序写法

```cpp
//左闭右闭
//占坑法
void qsort(vector<int>& v,int left,int right) {
	if (left < right) {
		int l = left;int r = right;int tmp = v[left];
		while(l < r) {
            //因为可能有重复的元素，由于最后的跳出条件是左右边界相交，所以等于tmp的时候也需要前进，才能够边界相交，否则永远不会相交.
			while(l < r&&v[r] >= tmp)r--;
			v[l] = v[r];
			while(l < r&&v[l] <= tmp)l++;
			v[r] = v[l]; 
		}
		v[l] = tmp;
		qsort(v,left,l);
		qsort(v,l+1,right);
	}
}
```

第k小的写法

```cpp
#include<bits/stdc++.h>
using namespace std; 

class Solution {
public:
	vector<int> ans;
	void sortK(vector<int>& arr,int k,int left,int right){
		if(left >= right)return;
		int i = left;int j = right;int tmp = arr[left];
		while(i < j){
			while(i < j&arr[j] >= tmp)j--;
			arr[i] = arr[j];
			while(i < j&&arr[i] <= tmp)i++;
			arr[j] = arr[i];
		} 
		arr[i] = tmp;
		if(i+1 == k){
			return;
		}
		else if(i+1 < k)sortK(arr,k,i+1,right);
		else sortK(arr,k,left,i);
	}
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
    	sortK(arr,k,0,arr.size()-1);
        for(int t = 0;t < k;t++){
			ans.push_back(arr[t]);
		}
		return ans;
    }
};
```





## Java基础学习   

### 1.HashMap源码分析

https://juejin.im/post/6844903799748821000



### 2.java自动装箱和拆箱机制

```java
Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()
```

在使用valueOf的时候会去缓存池里寻找对象。

因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。超出缓存池范围的就不相同。

如果是new的话都不相同。



### 3.String

- 不可变
- buffer是线程安全的，builder不安全
- 用字面量创建时，都会放进pool中，所以相同，不像Integer有范围限制。



### 4.值传递

java所有的都是值传递



### 5.抽象类和接口的不同

https://juejin.im/post/6844903734263152654

抽象类是事物的抽象，接口是行为的抽象



### 6.java泛型编程

https://blog.csdn.net/s10461/article/details/53941091

**泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。**



### 7.HashMap为什么不是线程安全的

https://juejin.im/post/6844903796225605640

#### 1.put导致丢失

![image-20200829154137884](C:\Users\hp\Desktop\面试\interviewMaterial\pic\image-20200829154137884.png)

两个线程同时put的时候，都在p指针的后面进行节点的增加（拉链），后面添加的一个节点挤掉之前新建的节点。

#### 2.put和get并发时，可能导致get为null

![image-20200829154748132](C:\Users\hp\Desktop\面试\interviewMaterial\pic\image-20200829154748132.png)

resize后table都是新的，如果另外一个进程进行get，此时get会得到null



### 8.jvm内存模型

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5778d113-8e13-4c53-b5bf-801e58080b97.png)

线程独占的：pc计数器，java虚拟栈，本地方法栈，

线程共享的：堆，方法区



### 9.垃圾回收

见《深入理解java虚拟机》

#### 1.垃圾回收算法

- 标记-清除算法
- 标记-复制算法
- 标记-整理算法

新生代使用：复制算法

老年代使用：标记 - 清除 或者 标记 - 整理 算法

#### 2.经典收集器

![](https://camo.githubusercontent.com/2deabe6ad312b7f211941d24a4241fbb00a8c22f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63363235626161302d646465362d343439652d393364662d6333613637663266343330662e6a7067)

##### CMS

![cms流程](https://camo.githubusercontent.com/2eb375354cc7b06ee58cbc8a1aa7b18907208d91/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326537373939372d363935372d346236382d386431322d6266643630396262326336382e6a7067)

需要"stop the world"的地方，初始标记和重新标记。

初始标记，只记录一下gc root的直接的子节点，在并发标记的过程中进行遍历，重新标记是记录在并发标记途中又进行了修改的地方，之后并发的清理，使用的算法是标记-清理算法。

具有以下缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

##### G1收集器

![g1](https://camo.githubusercontent.com/5bd72d589ead80c22547e3288a9a406241a1fb6b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393965653737312d633536662d343766622d393134382d6330303336363935623566652e6a7067)




## 计算机网络

### 1.http和https的区别

https过程：

1. 首先是客户端向服务端发送请求；
2. 服务端向客户端发送自己的ssl证书；
3. 客户端验证证书后，得到证书中的公钥，之后生成对称加密算法所需要的密钥和算法，用公钥加密后发送给客服务端；
4. 服务端获得信息后，使用自己的私钥进行解密，得到对称密钥和算法，之后发送信息时使用对称加密的方式进行交流。

http 端口为80 https端口为443

HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包（具体可查看马海祥博客《[HTTP服务的七层架构技术解析及运用](http://www.mahaixiang.cn/internet/801.html)》的相关介绍）；HTTPS除了TCP的三个包，还要加上ssl握手需要的9个包，所以一共是12个包。

缺点 ：加载速度慢，且费用较高



### 2.数据链路层

![image-20200323172500056.png](https://i.loli.net/2020/08/25/DPSRun4eVqMks5A.png)

差错检测：CRC，校验和 

差错控制：回退N协议，选择性重传

介质访问控制：广播信道：CSMA/CD，信道复用 

​                           点对点信道：PPP协议 MAC地址

​                           以太网 透明网桥 VLAN



### 3.网络层

和IP相关的协议。

ARP协议 通过询问IP地址得知MAC地址

DHCP协议 客户端在加入网络的时候 租用IP地址

ICMP协议  消息控制协议



和路由器相关的协议

RIP协议  

OSPF协议

BGP协议



### 4.传输层

![image-20200328075224512.png](https://i.loli.net/2020/08/26/6s94jYgmZQvAnVN.png)

![image-20200328075244121.png](https://i.loli.net/2020/08/26/FixvHfr3Bg8nMYT.png)



- ###### TCP的三次握手


①服务端创建传输控制块TCB，进入LISTEN状态，准备接收客户端的请求。客户端同样先创建TCB，然后当准备建立连接时向服务端发送连接请求报文（SYN=1，seq=x），然后进入SYN-SENT状态。②服务端收到后向客户端发送确认报文（SYN=1，ACK=1，ack=x+1，seq=y），进入SYN-RCVD状态。③客户端接收到确认后，再向服务端发送一个确认报文（ACK=1，ack=y+1，seq=x+1），然后进入ESTABLISHED状态，服务端接收后也进入ESTABLISHED状态。
④不是两次的原因是为了避免无效的连接请求突然发送到服务端，而此时客户端已关闭，服务端误以为客户端将要发送数据会白白浪费资源。⑤不是四次的原因是将服务端的SYN和ACK报文拆分成两次发送和一次的效果是相同的，没有意义。



- ###### TCP的四次挥手过程


①当客户端准备关闭连接时，向服务端发送连接终止报文（FIN=1，seq=u），进入FIN-WAIT-1状态。②服务端接收后向客户端发送确认报文（ACK=1，ack=u+1，seq=v），进入CLOSE-WAIT状态，客户端收到后进入FIN-WAIT-2状态，此时TCP连接处于半关闭状态。③当服务端也发送完全部数据准备断开连接时，向客户发送连接终止报文（FIN=1，ACK=1，ack=u+1，seq=w），进入LAST-ACK状态。④客户端接收到该报文后，发送一个确认报文（ACK=w+1，ack=1，seq=u+1），进入TIME-WAIT状态，然后等待2MSL时间后关闭。服务端收到后关闭，时间将略早于客户端。⑤不是三次的原因第一是为了保证客户端发送的最后一个报文可以到达服务端，如果该报文丢失那么服务端会超时重传之前的FIN+ACK报文，客户端可以在2MSL内收到，第二是防止已失效的报文发送到客户端，在2MSL后客户端在本连接时间内发出的所有报文都将从网络中消失。

客户端发起关闭请求后，服务器端可能还有数据要继续发送没有发送完，所以先发送ACK，表示答应让客户端继续等待消息，之后在确保发送数据完成后，发送自己的关闭请求。



- TCP拥塞控制：

拥塞控制是一个全局性的过程； 流量控制是点对点通信量的控制
　　TCP拥塞控制4个核心算法：慢开始（slow start）、拥塞避免（Congestion Avoidance）、快速重传（fast retransmit）、快速回复（fast recovery）
　　拥塞窗口（cwnd，congestion window），其大小取决于网络的拥塞程度，并且动态地在变化。

慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

> 为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：
> 当cwnd < ssthresh时，使用慢开始算法。
> 当cwnd > ssthresh时，改用拥塞避免算法。
> 当cwnd = ssthresh时，慢开始与拥塞避免算法任意。

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送发的拥塞窗口cwnd加1，而不是加倍。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如下图：

![image.png](https://upload-images.jianshu.io/upload_images/11281208-d76e6c85873fbef8.png?imageMogr2/auto-orient/strip)

拥塞控制的具体过程如下：
（1）TCP连接初始化，将拥塞窗口设置为1
（2）执行慢开始算法，cwnd按指数规律增长，直到cwnd=ssthresh时，开始执行拥塞避免算法，cwnd按线性规律增长
（3）当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，按照步骤（2）执行

乘法减小：是指不论在慢开始阶段还是拥塞避免阶段，只要出现超时，就把慢开始门限减半，即设置为当前的拥塞窗口的一半（于此同时，执行慢开始算法）。当网络出现频繁拥塞时，ssthresh值就下降的很快，以大大将小注入到网络中的分组数。

加法增大：是指执行拥塞避免算法后是拥塞窗口缓慢增大，以防止网络过早出现拥塞。



快速重传(Fast retransmit)要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。
　　快重传算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。

快速恢复(Fast Recovery)
（1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。
（2）由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

```
发送方窗口的上限值 = Min [ rwnd, cwnd ]
当rwnd < cwnd 时，是接收方的接收能力限制发送方窗口的最大值。
当cwnd < rwnd 时，则是网络的拥塞限制发送方窗口的最大
```





### 5.对称加密和非对称加密

对称加密只需要公钥，被黑客拦截不安全

非对称加密既有公钥又有私钥。

![image-20200330154408649.png](https://i.loli.net/2020/08/26/5obuekAI2LE3xpP.png)

由于纯粹的非对称加密比较的慢，所以一般是非对称和对称加密一起使用。类似于https的开始环节。

但这里需要注意“中间人攻击”，发送公钥的时候，被中间人截取，假装为A要通信的B，发回一个用A公钥进行加密后的key，中间人再和B发送自己的公钥，进行加密连接。这样依然可以获取明文，被攻击。所以https加上了一个认证的证书。



### 6.Http的传输过程

①地址解析：地址解析通过域名系统DNS解析服务器域名从而获得主机的IP地址。例如客户端的浏览器请求http://localhost:8080/index.html，则可分析出：协议名HTTP、主机名localhost、端口8080、对象路径/index.html。②封装HTTP数据包：解析协议名、主机名、端口、对象路径等并结合本机自己的信息封装成一个HTTP请求数据包。③封装TCP包：将HTTP请求数据包进一步封装成TCP数据包。④建立TCP连接：基于TCP的三次握手机制建立TCP连接。⑤客户端发送请求：在建立连接后，客户端发送一个请求给服务器。⑥服务器响应：服务器在接收到请求后，结合业务逻辑进行数据处理，然后向客户端返回相应的响应信息。在响应信息中包含状态行、协议版本号、成功或错误的代码、消息体等内容。⑦服务器关闭TCP连接：服务器在向浏览器发送请求响应数据后关闭TCP连接。但如果浏览器或者服务器在消息头加入了Connection : keep-alive，则TCP连接在请求响应数据后仍然保持连接状态，在下一次请求中浏览器可以继续使用相同的连接发送请求。采用keep-alive不但减少了请求响应的时间，还节约了网络带宽和系统资源。




## 操作系统

### 1.进程和线程

- 一个进程中至少有一个线程运行，可以有多个线程

- 不同进程间数据共享困难，而同一进程下的线程数据共享容易
- 进程切换需要保存的数据量多，上下文环境复杂，线程的切换容易，保存少量寄存器。

线程安全问题：

多个线程并发运行的环境下，多个线程访问同一个共享的内存资源时，不同线程的读写问题。例如，一个线程读之后，还没有完成写操作的时候，另一个线程也进行了读，读取的是之前的数据，而非已经改过的数据，造成资源出错。类似于生产者消费者问题。



### 2.并发和并行

并行是多个内核同一时间运行不同的线程，而并发是利用cpu调度来实现线程的同时运行。



### 3.进程调度算法

批处理系统：

1.先来先服务

2.短作业优先

3.最短剩余时间优先

交互式系统：

1.时间片轮转

2.优先级调度

3.多级反馈队列



### 4.死锁

死锁一般具有四个特性：

1.互斥条件：只有一把钥匙

2.请求与保持条件：拿着红钥匙的人在没有归还红钥匙的情况下，又提出要蓝钥匙

3.不剥夺条件:人除非归还了钥匙，不然一直占用着钥匙

4.环路等待条件：拿着红钥匙的人在等蓝钥匙，同时那个拿着蓝钥匙的人在等红钥匙

破坏死锁的条件一般就是破坏其中一种条件即可。



### 5.虚存技术

分页见计算机组成原理的地方。 

分段。



### 6.生产者消费者问题

```text
mutex = 1
empty = n
full = 0

void producer(){
     p(empty)
     p(mutex)
     insert_item()
     v(mutex)
     v(full)
}

void customer(){
     p(full)
     p(mutex)
     delete_item()
     v(mutex)
     v(empty)
}
```

两个p操作不能够进行交换：假设交换之后，首先将缓冲区进行锁定，如果当前已经没有剩余的空间的话，那么就会将进程挂起，而如果生产者进程挂起的话，消费者进程不能够进入那么就会死锁。



### 7.同步和异步

这个概念针对的是**消息通信机制**，同步的话，需要自己去查询函数是否已经完成，而异步的话，是函数自己告诉你是否完成。



### 8.进程间通信

两个机器间可以通过socket来进行进程间的通信。



## 计算机组成原理

### 1.CPU工作过程

![image-20200427092756498.png](https://i.loli.net/2020/08/26/UCeEiTsxHZz2kor.png)

取出程序计数器中指向的指令放进指令寄存器中，根据指令取出数据或是操作数据，得到结果。



### 2.Cache

是放在CPU和内存之间的缓存。CPU中放有寄存器速度快于Cache，Cache速度快于内存。SRAM。



### 3.虚存分页技术

![img](http://c.biancheng.net/cpp/uploads/allimg/140701/1-140F102004L08.jpg)

页表在内存中，TLB是Cache。MMU内存管理单元，用来转换逻辑地址为物理地址。

先将逻辑地址mod页面的大小，得到虚拟的页号，通过上述图片的过程找到对应的物理页号，然后加上偏移量来得到物理地址。



## 数据库

### **[mysql详解](https://juejin.im/post/6850037271233331208#heading-35)**

### 1.B树和B+树的区别

1.单一节点存储的元素更多，使得查询的IO次数更少，所以适合作为MySQL的底层数据结构。

2.所有的查询都要查找叶子节点，查询性能更加稳定，而B树每一个节点都可以查找到数据，所以不稳定。

3.所有的叶子节点形成有序链表，更加便于查询。



### 2.数据库范式

https://www.cnblogs.com/wsg25/p/9615100.html

第一范式：**要求数据库表的每一列都是不可分割的原子数据项。**

第二范式：**第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关**

第三范式：**第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**



### 3.数据库的隔离级别

未提交读 已提交读 可重复读 可串行化



### 4.隔离性问题

脏读 不可重复读 幻读

![image-20200808175214680.png](https://i.loli.net/2020/08/26/dhvqfSOgc1IzWke.png)

![image-20200808175245158.png](https://i.loli.net/2020/08/26/6NCAJWMjzvb8lLn.png)

![image-20200808175229534.png](https://i.loli.net/2020/08/26/aic5EeXWBK49UvL.png)

脏读：事务读取到另一个事务还没有提交的事务，如果发生回滚读到的数据就为脏数据。

不可重复读：一个事务前后两次读，数据不一样。

幻读：前后两次读，数据的数量不同。



### 5.索引

聚集索引：主键，变成了b+树(平衡树)结构，方便进行查询。

![img](https://pic1.zhimg.com/v2-2ce9fa4e6d645ed4f105b8334fc2c488_b.jpg)

非聚集索引：通过非主键的部分建立，建立新的索引。查询时通过索引查询到主键的id再在主键建立的索引上进行查询。

![img](https://pic4.zhimg.com/v2-fbb0e0b277cc1177d2e76518793f99cf_b.jpg)

通过建立索引，使得查询加快，但是会使得存储之类的操作变慢，因为要维护一个树形的结构。

**MYSQL最左前缀匹配原则**

关于最左前缀的使用，有下面两条说明：

- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

单独只用一个b=2的话会采用index匹配的索引

![image-20200421103800858.png](https://i.loli.net/2020/08/26/GidhqRvSY8DlIKX.png)

一般正常能够加快搜索的索引都是type为**ref**的索引。



### 6.表的连接

inner join，left join，right join ,全外连接



### 7.ACID

原子性，隔离性，持久性，一致性。

原子性：一个事务要么都完成，要么都不做

隔离性：事务之间互不影响

持久性：数据库发生故障也不会对已经提交的数据有影响

一致性：事务前后状态一致，状态正确。



### 8.X/S锁

X：事务对资源A进行上锁后，既能对他读又能对他写，但是其他的事务不能够进行加锁。

S：事务对资源上锁后，只能对他读不能对他写，其他的事务也只能够对他进行加S锁。



### 9.乐观锁和悲观锁

#### 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。

#### 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。



### 10.引擎对比

![image-20200825112802357.png](https://i.loli.net/2020/08/26/lLX2DxpRtHMIJFs.png)



## 缓存

### 1.实现分布式锁

https://juejin.im/post/6844904082860146695#heading-2

基本原理

![img](https://user-gold-cdn.xitu.io/2020/3/4/170a4871a05c2531?imageslim)

其中可能存在的问题：

1.没有设置超时时间，导致持有的进程一直不释放，最后无法进行。    所以需要设置超时时间。

2.需要设置唯一的value，避免锁删除的问题，因为A进程操作时间过长，超过超时时间导致锁释放，此时B进程获得锁，如果不设置value，进程A可能直接把锁给删除掉。

![img](https://user-gold-cdn.xitu.io/2020/3/4/170a4b639f36b8d4?imageslim)

3.释放锁的写法问题

lua脚本删除，使得操作原子性。