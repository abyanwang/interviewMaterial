[TOC]

- [C++基础](#c基础)
  - [1.引用和指针的区别](#1引用和指针的区别)
  - [2.new delete malloc free](#2new-delete-malloc-free)
  - [3.vector和list的区别](#3vector和list的区别)
  - [4.vector的内存分配机制](#4vector的内存分配机制)
  - [5.set map](#5set-map)
  - [6.虚函数](#6虚函数)
  - [7.完全背包的推导](#7完全背包的推导)
  - [8.左闭右开的写法](#8左闭右开的写法)
  - [9.c++内存](#9c内存)
  - [10.static](#10static)
  - [11.vector deque](#11vector-deque)
  - [12.delete和delete[]](#12delete和delete)
  - [13.用delete和free](#13用delete和free)
  - [14.内存对齐](#14内存对齐)
  - [15.智能指针](#15智能指针)
  - [16.虚表](#16虚表)
  - [17.右值引用](#17右值引用)
  - [18.链接库](#18链接库)
  - [19.面向对象](#19面向对象)
  - [20.memcpy](#20memcpy)
- [Java基础学习](#java基础学习)
  - [1.HashMap源码分析](#1hashmap源码分析)
  - [2.java自动装箱和拆箱机制](#2java自动装箱和拆箱机制)
  - [3.String](#3string)
  - [4.值传递](#4值传递)
  - [5.抽象类和接口的不同](#5抽象类和接口的不同)
  - [6.java泛型编程](#6java泛型编程)
  - [7.HashMap为什么不是线程安全的](#7hashmap为什么不是线程安全的)
    - [1.put导致丢失](#1put导致丢失)
    - [2.put和get并发时，可能导致get为null](#2put和get并发时可能导致get为null)
    - [3.jdk1.7中会有两个并发put的时候导致死循环的情况](#3jdk17中会有两个并发put的时候导致死循环的情况)
  - [8.jvm内存模型](#8jvm内存模型)
  - [9.垃圾回收](#9垃圾回收)
    - [1.垃圾回收算法](#1垃圾回收算法)
    - [2.经典收集器](#2经典收集器)
      - [CMS](#cms)
      - [G1收集器](#g1收集器)
  - [10.volatile和synchronized](#10volatile和synchronized)
  - [11.理解Java的强引用、软引用、弱引用和虚引用](#11理解java的强引用软引用弱引用和虚引用)
    - [1. 强引用](#1-强引用httpscyc2018githubiocs-notesnotesjava-虚拟机id_1-强引用)
    - [2. 软引用](#2-软引用httpscyc2018githubiocs-notesnotesjava-虚拟机id_2-软引用)
    - [3. 弱引用](#3-弱引用httpscyc2018githubiocs-notesnotesjava-虚拟机id_3-弱引用)
    - [4. 虚引用](#4-虚引用httpscyc2018githubiocs-notesnotesjava-虚拟机id_4-虚引用)
  - [12.线程池](#12线程池)
  - [13.互斥锁和自旋锁](#13互斥锁和自旋锁)
  - [14.类加载](#14类加载)
  - [15.ThreadLocal](#15threadlocal)
  - [16.new 一个对象](#16new-一个对象)
  - [17.static](#17static)
  - [18.synchronized原理](#18synchronized原理)
  - [19.ReentrantLock原理](#19reentrantlock原理)
- [Java C++综合理解](#java-c综合理解)
  - [1.创建对象数组](#1创建对象数组)
- [计算机网络](#计算机网络)
  - [1.http和https的区别](#1http和https的区别)
  - [2.数据链路层](#2数据链路层)
  - [3.网络层](#3网络层)
  - [4.传输层](#4传输层)
  - [5.对称加密和非对称加密](#5对称加密和非对称加密)
  - [6.Http的传输过程](#6http的传输过程)
  - [7.get和post的区别](#7get和post的区别)
  - [8.redirect  forward](#8redirect-forward)
  - [9.select poll epoll](#9select-poll-epoll)
  - [10.http2.0和http1.x](#10http20和http1x)
  - [11.socket](#11socket)
  - [12.url解析过程](#12url解析过程)
    - [1.DHCP配置主机信息](#1dhcp配置主机信息)
    - [2.ARP解析mac地址](#2arp解析mac地址)
    - [3.DNS解析](#3dns解析)
    - [4.HTTP请求页面](#4http请求页面)
  - [13.tcp粘包](#13tcp粘包)
  - [14.http和rpc](#14http和rpc)
  - [15.TCP第三次握手失败后怎么办？](#15tcp第三次握手失败后怎么办)
- [操作系统](#操作系统)
  - [1.进程和线程](#1进程和线程)
  - [2.并发和并行](#2并发和并行)
  - [3.进程调度算法](#3进程调度算法)
  - [4.死锁](#4死锁)
  - [5.虚存技术](#5虚存技术)
  - [6.生产者消费者问题](#6生产者消费者问题)
  - [7.同步和异步](#7同步和异步)
  - [8.进程间通信](#8进程间通信)
- [计算机组成原理](#计算机组成原理)
  - [1.CPU工作过程](#1cpu工作过程)
  - [2.Cache](#2cache)
  - [3.虚存分页技术](#3虚存分页技术)
- [数据库](#数据库)
  - [**mysql详解**](#mysql详解)
  - [1.B树和B+树的区别](#1b树和b树的区别)
  - [2.数据库范式](#2数据库范式)
  - [3.数据库的隔离级别](#3数据库的隔离级别)
  - [4.隔离性问题](#4隔离性问题)
  - [5.索引](#5索引)
  - [6.表的连接](#6表的连接)
  - [7.ACID](#7acid)
  - [8.X/S锁](#8xs锁)
  - [9.乐观锁和悲观锁](#9乐观锁和悲观锁)
    - [悲观锁](#悲观锁)
    - [乐观锁](#乐观锁)
  - [10.引擎对比](#10引擎对比)
  - [11.慢查询](#11慢查询)
  - [12.水平分表和垂直分表](#12水平分表和垂直分表)
  - [13.小表驱动大表](#13小表驱动大表)
  - [14.分库分表](#14分库分表)
  - [15.主从复制](#15主从复制)
- [缓存](#缓存)
  - [1.实现分布式锁](#1实现分布式锁)
  - [2.缓存雪崩，缓存击穿，缓存穿透](#2缓存雪崩缓存击穿缓存穿透)
  - [3.redis基本数据类型](#3redis基本数据类型)
    - [1.简单动态字符串](#1简单动态字符串)
    - [2.list使用场景](#2list使用场景)
    - [3.hash](#3hash)
  - [4.redis为什么快](#4redis为什么快)
  - [5.过期策略和内存淘汰机制](#5过期策略和内存淘汰机制)
- [设计模式](#设计模式)
  - [工厂模式](#工厂模式)
  - [单例模式](#单例模式)
  - [建造者模式](#建造者模式)
  - [代理模式](#代理模式)
- [Spring](#spring)
  - [1.spring MVC过程](#1spring-mvc过程)
  - [2.Spring Aop jdk代理和cglib代理](#2spring-aop-jdk代理和cglib代理)
- [GoLang](#golang)
  - [1.数组和切片](#1数组和切片)
  - [2.变量](#2变量)
  - [3.指针和接口](#3指针和接口)

## C++基础
### 1.引用和指针的区别

 对于指针来说，它是一个地址，这个地址是一个数值，那么就意味这个数值可以为0(空指针)，也可以为其他，即指针可以不指向任何东西。

而对于引用来说，他是一个外号，外号一定是“某个存在物体”的外号，所以引用不能为空，即不能存在空引用。

根据以上可知指针和引用的一个重要不同：**指针可以为空，引用不能为空。**这就意味着我们拿到一个引用的时候，是不需要判断引用是否为空的，而拿到一个指针的时候，我们则需要判断它是否为空。这点经常在判断函数参数是否有效的时候使用。
例如：

```cpp
void fun1(int *point)
{
     // 为了代码的稳健和安全，我们需要判断指针是否有效,通常做法是判断指针是否为
     // 空，其他的判断就需要根据函数的具体功能来判断了
     if(!point)
     {
        return;
     }
     // 函数实现
}

void fun2(int &refence)
{
     // 在这里，我们就不用担心refence是否为空
}
```


引用修饰函数参数还可以提高效率，例子如下：

```cpp
Class Object
{// 实现省略，只需要知道我们在这里声明了一个类，在下面我们要将这个类的对象作为
 // 函数参数类型来使用};
void fun1(Object obj)
{
     // 此函数声明中，obj是值传递，会产生一个临时对象
}
void fun2(Object &obj)
{
    // 我们不用检查obj是否为空，同时，使用引用传递，可以避免临时对象
}
```


我们根据前面的描述，还可以知道指针可以多次赋值，即在某时刻可以指向地址1，换个时候可以指向地址2，例如：

```cpp
int a = 0;
int b = 1;
int *point = NULL;
point = &a;     // 在某个时刻，指针可以指向a
point = &b;     // 换个时刻，指针可以指向b
```


而引用则不同，引用只能在初始化的时候就赋好值，之后就不能改变了，用外号的例子来说就是"明明"这个外号在出现的时候就是代指小明，之后“明明”这个外号就绑在小明身上了，它不能过段时间换成小暗的外号。代码如下：

```cpp
int xiaoming = 1;
int &refence_mingming = xiaoming;
int xiaoan = 2;
refence_mingming = xiaoan;           // error,引用不能换了
```



由以上可以，当我们需要某个是否指向为空的时候，我们就需要使用指针了，还有指向的对象需要变化的时候，我们也需要使用指针。其他地方一般推荐引用。

const修饰引用，使得引用不能够进行值的变化。

const修饰指针，有两种区别

```cpp
	int t = 10;
	int* const p = &t;
	int t1 = 11;
	p = &t1;//error
```

```cpp
    int t = 10;
	const int* p = &t;
	int t1 = 11;
	p = &t1;//true
```



### 2.new delete malloc free

malloc/free 

用来分配内存和释放内存。

new/delete

1. new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
3. new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。



### 3.vector和list的区别

vector为存储的对象分配一块连续的地址空间，因此对vector中的元素随机访问效率很高。在vector中插入或者删除某个元素，需要将现有元素进行复制，移动。如果vector中存储的对象很大，或者构造函数复杂，则在对现有元素进行拷贝时开销较大，因为拷贝对象要调用拷贝构造函数。对于简单的小对象，vector的效率优于list。vector在每次扩张容量的时候，将容量扩展2倍，这样对于小对象来说，效率是很高的。

list中的对象是**离散存储**的，随机访问某个元素需要遍历list。在list中插入元素，尤其是在首尾插入元素，效率很高，只需要改变元素的指针。



### 4.vector的内存分配机制

vector所有的内存相关问题都可以归结于它的内存增长策略。vector有一个特点就是：内存空间只会增长不会减少。vector有两个函数，一个是capacity()，返回对象缓冲区（vector维护的内存空间）实际申请的空间大小，另一个size()，返回当前对象缓冲区存储数据的个数。对于vector来说，capacity是永远大于等于size的，当capacity和size相等时，vector就会扩容，capacity变大。

比如说vector最常用的push_back操作，它的整个过程是怎么一个机制呢？这个问题经常在面试中出现。

这个问题其实很简单，在调用push_back时，若当前容量已经不能够放入新的元素（capacity=size），那么vector会重新申请一块内存，把之前的内存里的元素拷贝到新的内存当中，然后把push_back的元素拷贝到新的内存中，最后要析构原有的vector并释放原有的内存。所以说这个过程的效率是极低的，为了避免频繁的分配内存，C++每次申请内存都会成倍的增长，例如之前是4，那么重新申请后就是8，以此类推。



### 5.set map

set和map内部都是使用红黑树进行实现  log(n)

加了unordered修饰的都是O(1)



### 6.虚函数

函数重载一般是指多个函数共用一个名字，用不同传递参数的方式来实现多态。

而在父类和子类之间，两个类中有不同的函数实现而函数名相同的函数时就会出现问题，子类函数在逻辑上虽然会继承父类的函数，但是两个函数并不能通过不同的参数传递方式来进行区分(会报错)。而且在使用指针指向类时，父类指针指向子类实体时，调用的还是父类的函数实现。

这是需要通过加上virtual来实现继承中的函数多态。

```cpp
#include<bits/stdc++.h>
using namespace std;

class A{
	public:
		void cal(){
			cout<<"A cal"<<endl;
		}
}; 

class B:public A{
	public:
		void cal1(){
			cout<<"B cal"<<endl;
		}
};

int main(){
	A *b = new B();
	b->cal();
	return 0;
}
```

这里使用A类指针指向B类实体，调用的cal()函数是A类的。

- 在java中extend一个父类，在子类中写和父类同样的方法，使用效果和c++的虚函数相同。

**虚析构函数**，如果不加virtual的话，那么在类的析构函数的调用需要根据指针来进行判断，如果是父类的指针，那么可能少析构子类中的内存。

```cpp
#include <iostream>
using namespace std;
 
class Base
{
private:
	int i;
public :
	Base()
	{
		cout << "Base count " << endl;
	}
	 ~Base()
	{ 
		cout << " Base descount" << endl;
	}
};
class Inherit :public Base
{
private:
	int num;
public: 
	Inherit()
	{
		cout << "Inherit count" << endl;
	}
	 ~Inherit()  
	{
		cout << "Inherit descout" << endl;
	}
};
int main()
{
	Base *p =  new Inherit();
	delete p;
	Base *q = new Base();
	delete q;
	return 0;
}
```

此时第一个p就只会析构父类中的内存，而不会调用子类的析构函数。

讲虚函数表的文章: https://blog.twofei.com/496/



**虚继承**

避免菱形继承问题

```cpp
class A    // 声明基类A
{
    // 代码
};
class B: virtual public A    // 声明类 B 是类 A 的公有派生类，A 是 B 的虚基类
{
    // 代码
};
class C: virtual public A    // 声明类 C 是类 A 的公有派生类，A 是 C 的虚基类
{
    // 代码
};
class D: public B, public C    // 类 D 中只有一份 A 的数据
{
    // 代码
};
```



### 7.完全背包的推导

```cpp
# dp[i][j] 使用前i种硬币计算j分的表示法种数 令coins=[25, 10, 5, 1]
# dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
# j >= k*coins[i]
# dp[i][j-coins[i]] = dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
# dp[i][j] - dp[i][j-coins[i]] = dp[i-1][j]
# dp[i][j] = dp[i][j-coins[i]] + dp[i-1][j]

dp[j] = dp[j]+dp[j-coins[i]];
```

从0开始更新第i个的状态。已经更新的为f(i,j-coins[i]),加上本身还没有更新的自己f(i-1,j);



### 8.左闭右开的写法

二分查找中写成左闭右开，主要看left的操作，left为可以取到的，而二分查找尽量写成都越过mid，即都不取到mid。最后l==r，表示将整个空间都搜索完全。

而搜索中写成左闭右开需要考虑到只剩下一个元素时即返回。所以一般为l+1 >= r时return。

双指针写法时不考虑这些。

https://www.luogu.com.cn/blog/HOJQVFNA/qian-tan-er-fen-di-bian-jie-wen-ti

快速排序写法

```cpp
//左闭右闭
//占坑法
void qsort(vector<int>& v,int left,int right) {
	if (left < right) {
		int l = left;int r = right;int tmp = v[left];
		while(l < r) {
            //因为可能有重复的元素，由于最后的跳出条件是左右边界相交，所以等于tmp的时候也需要前进，才能够边界相交，否则永远不会相交.
			while(l < r&&v[r] >= tmp)r--;
			v[l] = v[r];
			while(l < r&&v[l] <= tmp)l++;
			v[r] = v[l]; 
		}
		v[l] = tmp;
		qsort(v,left,l);
		qsort(v,l+1,right);
	}
}
```

第k小的写法

```cpp
#include<bits/stdc++.h>
using namespace std; 

class Solution {
public:
	vector<int> ans;
	void sortK(vector<int>& arr,int k,int left,int right){
		if(left >= right)return;
		int i = left;int j = right;int tmp = arr[left];
		while(i < j){
			while(i < j&arr[j] >= tmp)j--;
			arr[i] = arr[j];
			while(i < j&&arr[i] <= tmp)i++;
			arr[j] = arr[i];
		} 
		arr[i] = tmp;
		if(i+1 == k){
			return;
		}
		else if(i+1 < k)sortK(arr,k,i+1,right);
		else sortK(arr,k,left,i);
	}
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
    	sortK(arr,k,0,arr.size()-1);
        for(int t = 0;t < k;t++){
			ans.push_back(arr[t]);
		}
		return ans;
    }
};
```



### 9.c++内存

堆，栈，全局存储，代码区。

https://www.cnblogs.com/WindSun/p/11444429.html

https://www.cnblogs.com/southcyy/p/10167005.html



### 10.static

https://zhuanlan.zhihu.com/p/37439983

- 静态成员变量：被所有该类的对象所共有，存储在全局数据区，所以可以用来计数。
- 静态成员函数：与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，**因此静态成员不能访问非静态成员**。 这一点和java相似
- 静态全局变量：申明了之后不能够被外部的文件使用
- 静态局部变量：存在全局数据区
- 静态函数：不被外部文件所调用。



### 11.vector deque

vector：

元素在内存中是连续存放的。

随机存取时间：常数时间（因为可以通过下标直接访问到地址）。

在尾部增删元素通常是常数时间（正常是常数时间，如果超出了默认分配的元素个数，会重新分配存储空间，此时会消耗更多时间)。

在中间或者头部增删元素：o(n)（会移动其他元素的位置）。

迭代器类型：随机访问(支持下标访问、随机移动，例：a[i])。

查询时间：o(n)（因为没有排序，只能现行查找，效率较低）。

可见vector在中间或者头部增删元素性能较低。

**优点：内存和C完全兼容、高效随机访问、节省空间**

**缺点：内部插入删除元素代价巨大、动态大小查过自身容量需要申请大量内存做大量拷贝**。



deque：

https://cloud.tencent.com/developer/article/1338355

结合vector和list的特点综合起来，deque中有一段一段的连续空间，所以在头部和尾部进行添加都不需要像vector一样开辟一块更大的连续空间进行分配，只用找到一小块新的连续空间进行存放。还存在一个中控器，其中的元素指向对应的node(小块连续空间)，迭代器的增加的话，需要判断是否达到缓冲区末尾，看是否需要切到下一个节点。

同时在前面和后面插入需要考虑缓冲区的新建和指向问题，随机访问的效率仅次于vector



### 12.delete和delete[]

当用于基础类型的时候两者一样

```c++
int *p = new int[10];
delete p;
delete []p;
```

当用于对象数组时不同

```c++
Node* p = new Node[10]; //这里中p[i]为一个Node对象而不是指针  
// Node **p = new Node*[10];这种还需要单独赋值 里面是指针。 delete的时候也不能够用delete[]来delete掉数组 需要一个一个delete单个指针。
delete p;
delete []p;
```

对象数组建立的时候，会分配一块地址作为记录数组大小的地方，使用delete p只会析构一次，而delete[] p会析构建立的次数。就会出现和下面free一样的问题。



### 13.用delete和free

new出来的东西不能够free掉，虽然free会把这块内存给释放掉，但是没有使用析构函数，由于对象可能放一些指向内存的指针，如果只是把指针给free掉，也是无法将指向的地址给free掉的，所以需要delete。或者一些系统资源。



### 14.内存对齐

https://zhuanlan.zhihu.com/p/101140160

主要是变量存储的offset 为 min(n,N)的整数倍。

为了cpu读取的方便，因为cpu读取是有倍数的，如果卡在中间需要读两次才能够读完整这个变量。还考虑代码的移植性。

1. 当前变量的offset是min(4,自己的长度)的整数倍，否则给前面那个变量进行增加
2. 总的长度是4的倍数



### 15.智能指针

https://www.cnblogs.com/xiehongfeng100/p/4645555.html

https://juejin.im/post/6844903542889644045

主要是利用引用计数的问题

```c++
//
// Created by hp on 2020/9/22.
//
#include<bits/stdc++.h>
using namespace std;

template<typename T>
class Share{
private:
    int* cnt = NULL;
    T* obj = NULL;
public:
    Share(T* p) {
        obj = p;
        if (cnt == NULL) {
            cnt = new int(1);
        }
        cout<<"cnt = "<<*(cnt)<<endl;
    }

    Share(Share& s) {
        obj = s.obj;
        cnt = s.cnt;
        (*cnt)++;
        cout<<"cnt = "<<*(cnt)<<endl;
    }

    ~Share() {
        (*cnt)--;
        cout<<"cnt = "<<*cnt<<endl;
        if ((*cnt) == 0) {
            delete obj;
            delete cnt;
            obj = NULL;
            cnt = NULL;
        }
    }

    Share& operator=(Share& share) {
        if (this == &share) {
            return *this;
        }
        (*cnt)--;
        if ((*cnt) == 0) {
            delete obj;
            delete cnt;
        }
        obj = share.obj;
        cnt = share.cnt;
        (*cnt)++;
        return *this;
    }

    T* operator->() {
        return obj;
    }
};

class A{
public:
    int a;
    A(int a) {
        a = 0;
    }
    A() {
        a = 0;
    }
};

int main() {
    A* a = new A();
    Share<A> share(a);
    Share<A> share1(share);
    A* b = new A();
    b->a = 1000;
    Share<A> share2(b);
    share2 = share1;
}
```



### 16.虚表

使用了virtual的函数在对象开始的四个字节的地方存放了指向虚函数表的对象的指针，所以能够保证使用虚函数的动态绑定。



### 17.右值引用

https://zhuanlan.zhihu.com/p/107445960

左值就是可以比较长时间存储的变量，右值是无法存储的临时变量，右值是无法使用左值引用的。但是右值引用的变量也是左值。

在 C++ 11 强化了左右值概念后，提出了 **移动语义** *(move semantic)* 优化：由于右值对象一般是临时对象，在移动时，对象包含的资源 **不需要先拷贝再删除**，只需要直接 **从旧对象移动到新对象**。

```cpp
A(const A& a) { //是拷贝构造
    cout<<"l copy construct"<<endl;
}
A(const A&& a) { //是移动语义。
    cout<<"r copy construct"<<endl;
}
```

像智能指针unique_ptr由于不能够有多的引用，所以只能使用移动语义。



### 18.链接库

静态链接和动态链接



### 19.面向对象

1. 封装

   将数据和操作数据的操作封装到一起，构建成一个类，能够降低耦合，开发效率高

2. 继承

   子类继承父类

3. 多态

   包括编译时多态和运行时多态，编译时多态主要是指函数的overload(重载)，运行的多态就是指父类指针指向子类实体，运行时选择子类的方法。



### 20.memcpy

```c++
void *  my_memcpy(void* dst, void*src, int n) {
    if (dst == NULL || src == NULL)return NULL;
    char* cdst = (char*)(dst);
    char* csrc = (char*)(src);
    if (cdst > csrc && cdst < csrc+n) {
        for (int i = n-1;i >= 0;i--) {
            cdst[i] = csrc[i];
        }
    } else {
        for (int i = 0;i < n;i++) {
            cdst[i] = csrc[i];
        }
    }
    return dst;
}
```

有重叠的地方，从高位到低位复制。







## Java基础学习   

### 1.HashMap源码分析

https://juejin.im/post/6844903799748821000

最主要的思路是拉链法的思路，jdk1.7中使用的头插法，jdk1.8之后使用的是尾插法，头插法在并发的环境下使用会造成成环的问题。

```java
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
             //如果table尚未初始化，则此处进行初始化数组，并赋值初始容量，重新计算阈值
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            //通过hash找到下标，如果hash值指定的位置数据为空，则直接将数据存放进去
            tab[i] = newNode(hash, key, value, null);
        else {
            //如果通过hash找到的位置有数据，发生碰撞
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                //如果需要插入的key和当前hash值指定下标的key一样，先将e数组中已有的数据
                e = p;
            else if (p instanceof TreeNode)
                //如果此时桶中数据类型为 treeNode，使用红黑树进行插入
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                //此时桶中数据类型为链表
                // 进行循环
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        //如果链表中没有最新插入的节点，将新放入的数据放到链表的末尾
                        p.next = newNode(hash, key, value, null);

                        //如果链表过长，达到树化阈值，将链表转化成红黑树
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    //如果链表中有新插入的节点位置数据不为空，则此时e 赋值为节点的值，跳出循环
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }

            //经过上面的循环后，如果e不为空，则说明上面插入的值已经存在于当前的hashMap中，那么更新指定位置的键值对
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        //如果此时hashMap size大于阈值，则进行扩容
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }

```

扩容的流程：

先扩容成两倍，再将旧的node上链表的值复制到新的table中指定的位置。



ConcurrentHashMap：

jdk1.7中使用的segment来控制一段一段的node数组，而在jdk1.8中直接使用node来为锁的最小的粒度。

- 第一个扩容线程进来后创建nextTable数组，并设置transferIndex；

- 线程（第一个或其他）通过transferIndex-stride（扩容步长）来领取一个扩容子任务，transferIndex减到0说明所有子任务领取完成；

- 线程领取到扩容子任务后设置当前处理子任务的下界并更新当前处理节点所在的索引位置；

- 对子任务中的每个节点，扩容线程**从后向前**依次判断该节点是否已经转移，如果没有转移，则对该节点进行加锁，并且把节点对应的链表或红黑树转移到新数组nextTable中去；

- 如果线程处理的节点索引已经到达子任务的下界，则子任务执行结束，并尝试去领取新的子任务，若领取不到再判断当前线程是否是最后一个扩容线程，若是则最后扫描一遍数组，执行清理工作，否则直接退出。







### 2.java自动装箱和拆箱机制

```java
Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()
```

在使用valueOf的时候会去缓存池里寻找对象。

因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。超出缓存池范围的就不相同。

如果是new的话都不相同。



### 3.String

- 不可变
- buffer是线程安全的，builder不安全
- 用字面量创建时，都会放进pool中，所以相同，不像Integer有范围限制。



### 4.值传递

java所有的都是值传递



### 5.抽象类和接口的不同

https://juejin.im/post/6844903734263152654

抽象类是事物的抽象，接口是行为的抽象



### 6.java泛型编程

https://blog.csdn.net/s10461/article/details/53941091

**泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。**

```java
public class GenericTypes{
    public static void method(List<String> list) {
        System.out.println("invoke method(List<String> list)");
    }
    public static void method(List<Integer> list) {
        System.out.println("invoke method(List<Integer> list)");
    }
}
```

上面这段代码是不能被编译的，因为参数`List<Integer>和List<String>`编译之后都被擦除了，变成了一样的原生类型`List<E>`。

方法重载与返回值类型有关吗？**无关**

```java
private static void func(String s) {
    System.out.println("string");
}

private static void func(Object o) {
    System.out.println("object");
}

private static final int a[] = new int [10];

public static void main(String []args) {
    func(null);
    func(1);
}
```

调用null的时候，显示string ，因为有多个重载方法的时候，调用最specific的函数 



### 7.HashMap为什么不是线程安全的

https://juejin.im/post/6844903796225605640

#### 1.put导致丢失

![image-20200829154137884.png](https://i.loli.net/2020/09/01/VICpcsohbQay4WD.png)

两个线程同时put的时候，都在p指针的后面进行节点的增加（拉链），后面添加的一个节点挤掉之前新建的节点。

#### 2.put和get并发时，可能导致get为null

![image-20200829154748132.png](https://i.loli.net/2020/09/01/G1Fta7ZfVKsuBx5.png)

resize后table都是新的，如果另外一个进程进行get，此时get会得到null

#### 3.jdk1.7中会有两个并发put的时候导致死循环的情况

https://www.jianshu.com/p/13c650a25ed3



### 8.jvm内存模型

**[jmm和jvm内存](https://www.cnblogs.com/kaleidoscope/p/9505829.html)**

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5778d113-8e13-4c53-b5bf-801e58080b97.png)

线程独占的：pc计数器，java虚拟栈，本地方法栈，

线程共享的：堆，方法区



### 9.垃圾回收

见《深入理解java虚拟机》

能做gc roots的对象：

1. 在虚拟栈中引用的对象
2. 静态属性引用的对象
3. 常量引用的对象



#### 1.垃圾回收算法

- 标记-清除算法
- 标记-复制算法
- 标记-整理算法

新生代使用：复制算法

老年代使用：标记 - 清除 或者 标记 - 整理 算法





#### 2.经典收集器

![](https://camo.githubusercontent.com/2deabe6ad312b7f211941d24a4241fbb00a8c22f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63363235626161302d646465362d343439652d393364662d6333613637663266343330662e6a7067)

##### CMS

![cms流程](https://camo.githubusercontent.com/2eb375354cc7b06ee58cbc8a1aa7b18907208d91/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326537373939372d363935372d346236382d386431322d6266643630396262326336382e6a7067)

需要"stop the world"的地方，初始标记和重新标记。

初始标记，只记录一下gc root的直接的子节点，在并发标记的过程中进行遍历，重新标记是记录在并发标记途中又进行了修改的地方，之后并发的清理，使用的算法是标记-清理算法。

具有以下缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

##### G1收集器

![g1](https://camo.githubusercontent.com/5bd72d589ead80c22547e3288a9a406241a1fb6b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393965653737312d633536662d343766622d393134382d6330303336363935623566652e6a7067)

![region](https://camo.githubusercontent.com/5049da1b34969b272be2bffc6c6de0206b33253c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39626264646565622d653933392d343166302d386538652d3262316130616137653061372e706e67)

从每个region来看，这是使用标记-复制的方法，从整体来看使用的是标记-整理的算法。



### 10.volatile和synchronized

https://juejin.im/post/6844904149536997384?utm_source=gold_browser_extension#heading-23

```java
public class test1 {
    public static void main(String []args) {
        Aobing a = new Aobing();
        a.start();
        while(true) {
            if (a.isFlag()) {
                System.out.println("有点东西");
            }
        }
    }
}

class Aobing extends Thread {
    private boolean flag = false;
    public boolean isFlag() {
        return flag;
    }

    @Override
    public void run() {
        //
        try {
            Thread.sleep(1000);
        } catch(Exception e) {
            e.printStackTrace();
        }
        flag = true;
        System.out.println("flag = "+flag);
    }
}
```

这个例子不能够输出有点东西的原因是子线程修改了flag不一定能够被主线程看到

一些主内存的拉取的问题https://blog.csdn.net/ren421259121/article/details/90447853

volatile主要的工作就是实现可见性，读取volatile类型的变量总是会返回最新写入的值。同时还会禁止这部分的代码进行指令重排，具体的实现是通过插入内存屏障来进行操作。

需要注意的是：volatile写是在前面和后面**分别插入内存屏障**，而volatile读操作是在**后面插入两个内存屏障**。

- synchronized也会保证可见性

  因为某一个线程进入synchronized代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁。



### 11.理解Java的强引用、软引用、弱引用和虚引用

https://juejin.im/post/6844903665241686029

#### [1. 强引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_1-强引用)

被强引用关联的对象不会被回收。

使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object();
```

#### [2. 软引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_2-软引用)

被软引用关联的对象只有在内存不够的情况下才会被回收。

使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联Copy to clipboardErrorCopied
```

#### [3. 弱引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_3-弱引用)

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

使用 WeakReference 类来创建弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

#### [4. 虚引用](https://cyc2018.github.io/CS-Notes/#/notes/Java 虚拟机?id=_4-虚引用)

又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。

为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

使用 PhantomReference 来创建虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```



### 12.线程池

https://juejin.im/post/6844903889678893063

![preview](https://picb.zhimg.com/v2-708af888a7b9863115479dada9d75da4_r.jpg)

java的线程池主要参数是核心线程数以及阻塞队列的选用，最大的线程数，以及一个线程空闲的时候存活的时间。

常见的线程池，fixed，cache，single，schedule 

fix是核心线程数和最大线程数相同

cache是核心线程数为0



### 13.互斥锁和自旋锁

互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程(线程A和线程B)，它们分别运行在Core0和 Core1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞 (blocking)，Core0 会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务(例如另一个线程C)而不必进行忙等待。而自旋锁则不然，它属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，那么线程A就会一直在 Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。

https://zhuanlan.zhihu.com/p/71156910



### 14.类加载

编译->加载->验证->准备->解析->初始化

准备过程就是为类定义的变量进行内存分配以及类变量初始化的过程





### 15.ThreadLocal

https://www.cnblogs.com/fsmly/p/11020641.html

ThreadLocal类型的本地变量是存放在具体的线程空间上，其本身相当于一个装载本地变量的工具壳，通过set方法将value添加到调用线程的threadLocals中，当调用线程调用get方法时候能够从它的threadLocals中取出变量。如果调用线程一直不终止，那么这个本地变量将会一直存放在他的threadLocals中，所以不使用本地变量的时候需要调用remove方法将threadLocals中删除不用的本地变量。



### 16.new 一个对象

首先判断是否这个类是否有被加载过，如果没有加载过，那么就需要进行类的加载过程，在加载和验证之后，就可以进行内存的分配，之后在初始化的过程中使用构造函数，进行构造。



### 17.static

java中static主要的作用就是不使用类的对象即可以使用类的变量或者函数，使用static的变量的时候，也是需要进行类的初始化的，就是按照正常的流程类的加载以及之后的一系列流程来进行初始化的。 



### 18.synchronized原理

HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

普通对象的对象头包括两部分：Mark Word 和 Class Metadata Address （类型指针），如果是数组对象还包括一个额外的Array length数组长度部分。

![img](https://user-gold-cdn.xitu.io/2018/9/6/165ada51fe7f6dab?imageslim)

每个对象都存在着一个 monitor 与之关联

![img](https://user-gold-cdn.xitu.io/2018/9/6/165ada570c8b7874?imageslim)



### 19.ReentrantLock原理

![preview](https://pic4.zhimg.com/v2-8be0ec286e81908e88b709603f98e61b_r.jpg)

https://www.cnblogs.com/liqiangchn/p/11960944.html

  

## Java C++综合理解

### 1.创建对象数组

```java
class Node {
    private int i;
    public Node(int t) {
        i = t;
    }
    public int getI() {
        return i;
    }
}

public class demo10 {
    public static void main(String []args) {
        Node[] t = new Node[10];
        for (int i = 0;i < t.length;i++) {
//            System.out.println(t[i].getI());
            t[i] = new Node(i+1);
        }
    }
}
```

java中建立对象数组，需要一个一个的赋值



```c++
class Node{
public:
    int * p;
    Node() {
        p = new int[10];
        for (int i = 0;i < 10;i++) {
            p[i] = i+1;
        }
    }
    ~Node() {
        delete[] p;
    }
    void print() {
        for (int i = 0;i < 10;i++) {
            printf("%d ",p[i]);
        }
        puts("");
    }
};

int main() {
    Node **t = new Node*[10];
    for (int i = 0;i < 10;i++) {
        t[i] = new Node();
        t[i]->print();
        delete t[i]; //一个一个删除。  delete[]感觉是为了数组中是对象的准备的。
    }
}
```

这种形式的时候，其中t[i] 为一个指针，指向一个node对象。

```c++
Node *t = new Node[10];
for (int i = 0;i < 10;i++) {
    //t[i] = new Node();
    t[i].print();
}
```

这种形式的时候，t[i]为一个对象，t[i] = *(new Node())

## 计算机网络

 应用层: 提供对某些专门应用的支持
 文件服务(FTP), 邮件(SMTP), 网页
(HTTP)
 传输层: 进程之间的数据传送 (端到端)
 TCP, UDP
 网络层: 路由选择，实现在互连网中的数
据传送 (主机到主机)
 IP, routing protocols
 数据链路层: 在物理网络中传送包 (跳到
跳, 节点到节点)
 PPP, Ethernet
 物理层: 线上的比特 (传送原始比特流)

### 1.http和https的区别

https过程：

1. 首先是客户端向服务端发送请求；
2. 服务端向客户端发送自己的ssl证书；
3. 客户端验证证书后，得到证书中的公钥，之后生成对称加密算法所需要的密钥和算法，用公钥加密后发送给客服务端；（这里使用数字签名来判断是否被篡改。）
4. 服务端获得信息后，使用自己的私钥进行解密，得到对称密钥和算法，之后发送信息时使用对称加密的方式进行交流。

http 端口为80 https端口为443

HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包（具体可查看马海祥博客《[HTTP服务的七层架构技术解析及运用](http://www.mahaixiang.cn/internet/801.html)》的相关介绍）；HTTPS除了TCP的三个包，还要加上ssl握手需要的9个包，所以一共是12个包。

缺点 ：加载速度慢，且费用较高





### 2.数据链路层

![image-20200323172500056.png](https://i.loli.net/2020/08/25/DPSRun4eVqMks5A.png)

差错检测：CRC，校验和 

差错控制：回退N协议，选择性重传

介质访问控制：广播信道：CSMA/CD，信道复用 

​                           点对点信道：PPP协议 MAC地址

​                           以太网 透明网桥 VLAN



### 3.网络层

和IP相关的协议。

ARP协议 通过询问IP地址得知MAC地址

DHCP协议 客户端在加入网络的时候 租用IP地址

ICMP协议  消息控制协议



和路由器相关的协议

RIP协议  

OSPF协议

BGP协议



### 4.传输层

![image-20200328075224512.png](https://i.loli.net/2020/08/26/6s94jYgmZQvAnVN.png)

![image-20200328075244121.png](https://i.loli.net/2020/08/26/FixvHfr3Bg8nMYT.png)



- ###### TCP的三次握手

①服务端创建传输控制块TCB，进入LISTEN状态，准备接收客户端的请求。客户端同样先创建TCB，然后当准备建立连接时向服务端发送连接请求报文（SYN=1，seq=x），然后进入SYN-SENT状态。②服务端收到后向客户端发送确认报文（SYN=1，ACK=1，ack=x+1，seq=y），进入SYN-RCVD状态。③客户端接收到确认后，再向服务端发送一个确认报文（ACK=1，ack=y+1，seq=x+1），然后进入ESTABLISHED状态，服务端接收后也进入ESTABLISHED状态。
④不是两次的原因是为了避免无效的连接请求突然发送到服务端，而此时客户端已关闭，服务端误以为客户端将要发送数据会白白浪费资源。⑤不是四次的原因是将服务端的SYN和ACK报文拆分成两次发送和一次的效果是相同的，没有意义。



- ###### TCP的四次挥手过程


①当客户端准备关闭连接时，向服务端发送连接终止报文（FIN=1，seq=u），进入FIN-WAIT-1状态。②服务端接收后向客户端发送确认报文（ACK=1，ack=u+1，seq=v），进入CLOSE-WAIT状态，客户端收到后进入FIN-WAIT-2状态，此时TCP连接处于半关闭状态。③当服务端也发送完全部数据准备断开连接时，向客户发送连接终止报文（FIN=1，ACK=1，ack=u+1，seq=w），进入LAST-ACK状态。④客户端接收到该报文后，发送一个确认报文（ACK=w+1，ack=1，seq=u+1），进入TIME-WAIT状态，然后等待2MSL时间后关闭。服务端收到后关闭，时间将略早于客户端。⑤不是三次的原因第一是为了保证客户端发送的最后一个报文可以到达服务端，如果该报文丢失那么服务端会超时重传之前的FIN+ACK报文，客户端可以在2MSL内收到，第二是防止已失效的报文发送到客户端，在2MSL后客户端在本连接时间内发出的所有报文都将从网络中消失。

客户端发起关闭请求后，服务器端可能还有数据要继续发送没有发送完，所以先发送ACK，表示答应让客户端继续等待消息，之后在确保发送数据完成后，发送自己的关闭请求。

TIME-WAIT状态，主动关闭的一方在返回最后一个ack之后会等待2MSL之后才会进入closed的状态，因为最后一个ack可能会在发给服务端的时候消失了，服务端会重传fin，来得到确认。以及连接之后重新连接的包的问题。



- TCP拥塞控制：

拥塞控制是一个全局性的过程； 流量控制是点对点通信量的控制
　　TCP拥塞控制4个核心算法：慢开始（slow start）、拥塞避免（Congestion Avoidance）、快速重传（fast retransmit）、快速回复（fast recovery）
　　拥塞窗口（cwnd，congestion window），其大小取决于网络的拥塞程度，并且动态地在变化。

慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

> 为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：
> 当cwnd < ssthresh时，使用慢开始算法。
> 当cwnd > ssthresh时，改用拥塞避免算法。
> 当cwnd = ssthresh时，慢开始与拥塞避免算法任意。

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送发的拥塞窗口cwnd加1，而不是加倍。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如下图：

![image.png](https://upload-images.jianshu.io/upload_images/11281208-d76e6c85873fbef8.png?imageMogr2/auto-orient/strip)

拥塞控制的具体过程如下：
（1）TCP连接初始化，将拥塞窗口设置为1
（2）执行慢开始算法，cwnd按指数规律增长，直到cwnd=ssthresh时，开始执行拥塞避免算法，cwnd按线性规律增长
（3）当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，按照步骤（2）执行

乘法减小：是指不论在慢开始阶段还是拥塞避免阶段，只要出现超时，就把慢开始门限减半，即设置为当前的拥塞窗口的一半（于此同时，执行慢开始算法）。当网络出现频繁拥塞时，ssthresh值就下降的很快，以大大将小注入到网络中的分组数。

加法增大：是指执行拥塞避免算法后是拥塞窗口缓慢增大，以防止网络过早出现拥塞。



快速重传(Fast retransmit)要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。
　　快重传算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。

快速恢复(Fast Recovery)
（1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。
（2）由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

```
发送方窗口的上限值 = Min [ rwnd, cwnd ]
当rwnd < cwnd 时，是接收方的接收能力限制发送方窗口的最大值。
当cwnd < rwnd 时，则是网络的拥塞限制发送方窗口的最大
```





### 5.对称加密和非对称加密

对称加密只需要公钥，被黑客拦截不安全

非对称加密既有公钥又有私钥。

![image-20200330154408649.png](https://i.loli.net/2020/08/26/5obuekAI2LE3xpP.png)

由于纯粹的非对称加密比较的慢，所以一般是非对称和对称加密一起使用。类似于https的开始环节。

但这里需要注意“中间人攻击”，发送公钥的时候，被中间人截取，假装为A要通信的B，发回一个用A公钥进行加密后的key，中间人再和B发送自己的公钥，进行加密连接。这样依然可以获取明文，被攻击。所以https加上了一个认证的证书。



### 6.Http的传输过程

①地址解析：地址解析通过域名系统DNS解析服务器域名从而获得主机的IP地址。例如客户端的浏览器请求http://localhost:8080/index.html，则可分析出：协议名HTTP、主机名localhost、端口8080、对象路径/index.html。②封装HTTP数据包：解析协议名、主机名、端口、对象路径等并结合本机自己的信息封装成一个HTTP请求数据包。③封装TCP包：将HTTP请求数据包进一步封装成TCP数据包。④建立TCP连接：基于TCP的三次握手机制建立TCP连接。⑤客户端发送请求：在建立连接后，客户端发送一个请求给服务器。⑥服务器响应：服务器在接收到请求后，结合业务逻辑进行数据处理，然后向客户端返回相应的响应信息。在响应信息中包含状态行、协议版本号、成功或错误的代码、消息体等内容。⑦服务器关闭TCP连接：服务器在向浏览器发送请求响应数据后关闭TCP连接。但如果浏览器或者服务器在消息头加入了Connection : keep-alive，则TCP连接在请求响应数据后仍然保持连接状态，在下一次请求中浏览器可以继续使用相同的连接发送请求。采用keep-alive不但减少了请求响应的时间，还节约了网络带宽和系统资源。



### 7.get和post的区别

1. get的参数存在url中，post的参数存在body中，因为url的长度的限制(通常是因为浏览器的区别)，所以get会有长度限制，还有一个问题就是url将参数明文，导致安全的问题
2. 语义的问题，虽然get和post都可以进行在服务器内部进行写入，通常会进行语义的区分，get表示读，post表示写，人为设定语义。

![http](https://s3.51cto.com/wyfs02/M02/22/DA/wKioL1MpX-qwK1-PAAExXPRpR8M814.jpg)



### 8.redirect  forward

https://blog.csdn.net/weixin_37766296/article/details/80375106

本质区别就是redirect是客户端行为，forward是服务器行为

1. request forward能够共享，而redirect相当一次新的请求，不能够用上一次的request的内容
2. redirect是服务端返回一个response，客户端通过这个response来进行新的一次请求。所以地址也会不一样。



### 9.select poll epoll

select方法本质其实就是维护了一个文件描述符（fd）数组，以此为基础，实现IO多路复用的功能。这个fd数组有长度限制，在32位系统中，最大值为1024个，而在64位系统中，最大值为2048个，这个配置可以调用

poll本质上和select没有区别，依然需要进行数据结构的复制，依然是基于轮询来实现，但区别就是，select使用的是fd数组，而poll则是维护了一个链表，所以从理论上，poll方法中，单个进程能监听的fd不再有数量限制。但是轮询，复制等select存在的问题，poll依然存在

epoll就是对select和poll的改进了。它的核心思想是基于事件驱动来实现的，实现起来也并不难，就是给每个fd注册一个回调函数，当fd对应的设备发生IO事件时，就会调用这个回调函数，将该fd放到一个链表中，然后由客户端从该链表中取出一个个fd，以此达到O（1）的时间复杂度

epoll是维护一个就绪的队列，从就绪队列里知道那些已经有返回了，然后去取相对应的socket

本质上select是数组轮询(32 1024 64 2048)，poll是链表轮询，epoll是有回调函数来获取就绪的io。

fd文件描述符





### 10.http2.0和http1.x

https://juejin.im/post/6844904072080801806

HTTP2性能提升的核心就在于二进制分帧层。HTTP2是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式。

- 多路复用 不用建立多个tcp连接，只用一个连接且实现并发，分帧来传递
- 头部压缩
- push机制，html中有css等，一并推送。



### 11.socket

unix五大io模型：

- 阻塞io
- 非阻塞io
- io多路复用
- 信号驱动io
- 异步io

前面四个是同步io，最后一个是异步io

![](https://camo.githubusercontent.com/d89aed2ba6c5390aad0626b013c288d8849c4f39/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932383130353739315f332e706e67)

send recv  tcp

sendto recvfrom udp



### 12.url解析过程

#### 1.DHCP配置主机信息

当主机没有配置ip地址的时候，通过DHCP协议，到交换机的DHCP服务器来获取ip地址，DNS服务器ip地址，以及路由网关的ip地址。

#### 2.ARP解析mac地址

因为需要解析DNS，所以要请求DNS服务器，所以需要先知道路由网关的mac地址(因为链路层需要mac地址才能够找到具体的主机)，因为以及知道了网关的ip地址，所以使用ARP协议来获得网关路由器的mac地址。

#### 3.DNS解析

得到网关路由器的mac地址后，就可以发送DNS解析的报文，通过路由网关发送报文到DNS服务器进行ip地址的获取

#### 4.HTTP请求页面

有了ip地址进行TCP连接，就正常的TCP通信。



### 13.tcp粘包

产生原因：

1. 写入数据较少，多个数据组合在一起来发送导致粘包
2. 写入数据较大，进行拆包，导致粘包
3. 接收方法不及时读取套接字缓冲区数据

拆包的方法：

1. 在头部给定长度，用于解析
2. 设置消息的边界，‘\r\n’
3. 定长消息



### 14.http和rpc

都是服务间通过网络进行通信，http基于http协议，rpc基于tcp/ip协议，而rpc需要限定更多，需要去注册中心注册服务还要暴露接口等一系列的东西，但是连接起来不需要那么多的流程比如三次握手这样的东西，连接起来高效一些。



### 15.TCP第三次握手失败后怎么办？

TCP has a sequence number in all packets. Hence it's easy to know if a packet was lost or not. If a host doesn't get an ACK on a packet he just resends it.

In most cases though, even if that ACK was lost, there will be no resending for a very simple reason. Directly after the ACK, the host that opened the TCP protocol is likely to start sending data. That data will, as all TCP packets, have an ACK number, so the recipient would get an ACK that way. Hence, the sender of the SYN-ACK should reasonably not care that it didn't get the ACK, because it gets an "implicit" ACK in the following package.

The re-send of the SYN-ACK is only necessary of there no data is received at all.

*Update:* I found the place in the RFC that specified exactly this:

> If our SYN has been acknowledged (perhaps in this incoming segment) the precedence level of the incoming segment must match the local precedence level exactly, if it does not a reset must be sent.

In other words, if the ACK is dropped but the next packet is not dropped, then everything is fine. Otherwise, the connection must be reset. Which makes perfect sense.



当之后的包是正常的时候，没有影响，因为会将ack带上，否则会当失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。这样做的目的是为了防止SYN洪泛攻击。






## 操作系统

### 1.进程和线程

- 一个进程中至少有一个线程运行，可以有多个线程

- 不同进程间数据共享困难，而同一进程下的线程数据共享容易
- 进程切换需要保存的数据量多，上下文环境复杂，线程的切换容易，保存少量寄存器。

线程安全问题：

多个线程并发运行的环境下，多个线程访问同一个共享的内存资源时，不同线程的读写问题。例如，一个线程读之后，还没有完成写操作的时候，另一个线程也进行了读，读取的是之前的数据，而非已经改过的数据，造成资源出错。类似于生产者消费者问题。



### 2.并发和并行

并行是多个内核同一时间运行不同的线程，而并发是利用cpu调度来实现线程的同时运行。



### 3.进程调度算法

批处理系统：

1.先来先服务

2.短作业优先

3.最短剩余时间优先

交互式系统：

1.时间片轮转

2.优先级调度

3.多级反馈队列



### 4.死锁

死锁一般具有四个特性：

1.互斥条件：只有一把钥匙

2.请求与保持条件：拿着红钥匙的人在没有归还红钥匙的情况下，又提出要蓝钥匙

3.不剥夺条件:人除非归还了钥匙，不然一直占用着钥匙

4.环路等待条件：拿着红钥匙的人在等蓝钥匙，同时那个拿着蓝钥匙的人在等红钥匙

破坏死锁的条件一般就是破坏其中一种条件即可。

https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81.md

### 5.虚存技术

分页见计算机组成原理的地方。 

分段。



### 6.生产者消费者问题

```text
mutex = 1
empty = n
full = 0

void producer(){
     p(empty)
     p(mutex)
     insert_item()
     v(mutex)
     v(full)
}

void customer(){
     p(full)
     p(mutex)
     delete_item()
     v(mutex)
     v(empty)
}
```

两个p操作不能够进行交换：假设交换之后，首先将缓冲区进行锁定，如果当前已经没有剩余的空间的话，那么就会将进程挂起，而如果生产者进程挂起的话，消费者进程不能够进入那么就会死锁。



### 7.同步和异步

这个概念针对的是**消息通信机制**，同步的话，需要自己去查询函数是否已经完成，而异步的话，是函数自己告诉你是否完成。

阻塞 当前线程阻塞了，但是可以挂起，cpu调用其他线程

非阻塞 当前线程没有阻塞，但是可能cpu调用多。



### 8.进程间通信

两个机器间可以通过socket来进行进程间的通信。



## 计算机组成原理

### 1.CPU工作过程

![image-20200427092756498.png](https://i.loli.net/2020/08/26/UCeEiTsxHZz2kor.png)

取出程序计数器中指向的指令放进指令寄存器中，根据指令取出数据或是操作数据，得到结果。



### 2.Cache

是放在CPU和内存之间的缓存。CPU中放有寄存器速度快于Cache，Cache速度快于内存。SRAM。



### 3.虚存分页技术

![img](http://c.biancheng.net/cpp/uploads/allimg/140701/1-140F102004L08.jpg)

页表在内存中，TLB是Cache。MMU内存管理单元，用来转换逻辑地址为物理地址。

先将逻辑地址mod页面的大小，得到虚拟的页号，通过上述图片的过程找到对应的物理页号，然后加上偏移量来得到物理地址。



## 数据库

### **[mysql详解](https://juejin.im/post/6850037271233331208#heading-35)**

### 1.B树和B+树的区别

1.单一节点存储的元素更多，使得查询的IO次数更少，所以适合作为MySQL的底层数据结构。

2.所有的查询都要查找叶子节点，查询性能更加稳定，而B树每一个节点都可以查找到数据，所以不稳定。

3.所有的叶子节点形成有序链表，更加便于查询。

和红黑树的比较

红黑树单节点，层数高。



### 2.数据库范式

https://www.cnblogs.com/wsg25/p/9615100.html

第一范式：**要求数据库表的每一列都是不可分割的原子数据项。**

第二范式：**第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关**

第三范式：**第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**



### 3.数据库的隔离级别

未提交读 已提交读 可重复读 可串行化



### 4.隔离性问题

脏读 不可重复读 幻读

![image-20200808175214680.png](https://i.loli.net/2020/08/26/dhvqfSOgc1IzWke.png)

![image-20200808175245158.png](https://i.loli.net/2020/08/26/6NCAJWMjzvb8lLn.png)

![image-20200808175229534.png](https://i.loli.net/2020/08/26/aic5EeXWBK49UvL.png)

脏读：事务读取到另一个事务还没有提交的事务，如果发生回滚读到的数据就为脏数据。

不可重复读：一个事务前后两次读，数据不一样。

幻读：前后两次读，数据的数量不同。



### 5.索引

聚集索引：主键，变成了b+树(平衡树)结构，方便进行查询。

![img](https://pic1.zhimg.com/v2-2ce9fa4e6d645ed4f105b8334fc2c488_b.jpg)

非聚集索引：通过非主键的部分建立，建立新的索引。查询时通过索引查询到主键的id再在主键建立的索引上进行查询。

![img](https://pic4.zhimg.com/v2-fbb0e0b277cc1177d2e76518793f99cf_b.jpg)

通过建立索引，使得查询加快，但是会使得存储之类的操作变慢，因为要维护一个树形的结构。



联合索引：https://juejin.im/post/6844904073955639304

**MYSQL最左前缀匹配原则**

关于最左前缀的使用，有下面两条说明：

- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

单独只用一个b=2的话会采用index匹配的索引

![image-20200421103800858.png](https://i.loli.net/2020/08/26/GidhqRvSY8DlIKX.png)

一般正常能够加快搜索的索引都是type为**ref**的索引。



### 6.表的连接

inner join，left join，right join ,全外连接

left join中on and和on where的区别

on and 无论是否为真都会显示，on where 则是表建好之后再过滤。



### 7.ACID

原子性，隔离性，持久性，一致性。

原子性：一个事务要么都完成，要么都不做

隔离性：事务之间互不影响

持久性：数据库发生故障也不会对已经提交的数据有影响

一致性：事务前后状态一致，状态正确。



### 8.X/S锁

X：事务对资源A进行上锁后，既能对他读又能对他写，但是其他的事务不能够进行加锁。

S：事务对资源上锁后，只能对他读不能对他写，其他的事务也只能够对他进行加S锁。



### 9.乐观锁和悲观锁

#### 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。

#### 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。



### 10.引擎对比

![image-20200825112802357.png](https://i.loli.net/2020/08/26/lLX2DxpRtHMIJFs.png)



### 11.慢查询

- 查询数据多
- 没有用到索引
- 并发的锁



### 12.水平分表和垂直分表

https://www.cnblogs.com/liliuguang/p/10935763.html

水平分表才是考虑数量的问题，垂直分表考虑逻辑上的分表。

需要考虑的问题

1. 事物一致性问题

2. 关联查询和排序

3. 主键的问题

   主键唯一性或者考虑使用无意义的主键来自增。





### 13.小表驱动大表

![img](https://pic2.zhimg.com/v2-51ac7193b5a80f5a1234df7dce23a2d8_b.jpg)


多表关联

第一张表是全表索引(要以此关联其他表)，其余表的查询类型type为range(索引区间获得)，也就是6 * 1 * 1，共遍历查询6次即可;

建议使用left join时，以小表关联大表，因为使用join的话，第一张表是必须全扫描的，以少关联多就可以减少这个扫描次数.

in的话先执行子查询，exists先执行主查询

https://www.jianshu.com/p/f6854f73f5ef



### 14.分库分表

水平分表：就是正常的分表依据数量来划分，寻找一个主维度来做hash来进行分库和分表

垂直分表：垂直分表考虑类似于范式这样的划分

可能存在的问题：

1. 分布式的事务问题
2. id唯一性问题



### 15.主从复制

![](https://camo.githubusercontent.com/0f6672e4eb9209a79edb5524df93e4c401753488/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6d61737465722d736c6176652e706e67)





## 缓存

### 1.实现分布式锁

https://juejin.im/post/6844904082860146695#heading-2

基本原理

![img](https://user-gold-cdn.xitu.io/2020/3/4/170a4871a05c2531?imageslim)

其中可能存在的问题：

1.没有设置超时时间，导致持有的进程一直不释放，最后无法进行。    所以需要设置超时时间。

2.需要设置唯一的value，避免锁删除的问题，因为A进程操作时间过长，超过超时时间导致锁释放，此时B进程获得锁，如果不设置value，进程A可能直接把锁给删除掉。

![img](https://user-gold-cdn.xitu.io/2020/3/4/170a4b639f36b8d4?imageslim)

3.释放锁的写法问题

lua脚本删除，使得操作原子性。



### 2.缓存雪崩，缓存击穿，缓存穿透

雪崩：缓存大面积同时失效，可以通过设置随机失效的时间

穿透：请求不存在缓存中也不存在数据库中的数据，导致一直请求数据库，把null返回回去。

击穿：热点key，导致失效时，大量请求，在失效后使用分布式锁，或者使用永不过期的方法。



### 3.redis基本数据类型

string，set，sort set，list，hash

跳跃表  https://www.cnblogs.com/hunternet/p/11248192.html

#### 1.简单动态字符串

```c++
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```

len代表长度，alloc (free)代表已经分配但是还没有使用的空间

![预分配策略](https://img-blog.csdn.net/20141009182943906)

#### 2.list使用场景

可以用来做消息队列

#### 3.hash

https://www.jianshu.com/p/4537467bb593

hash有两个表，使用渐进式hash，当ht[0]需要扩容的时候，先初始化ht[1]，在过程中多次调用rehash函数，将旧的ht[0]的数据逐步迁移到ht[1]中，在rehash过程中get某个值的时候可能需要两次查询，

<img src="https://user-gold-cdn.xitu.io/2018/9/17/165e6dc6a1e0c18e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="rehash"  />

### 4.redis为什么快

1. 数据存储在内存中，使用本身就快速
2. 单线程，可以减少一些一致性的操作，和上下文转换时间(存疑) 因为redis的瓶颈在于网络通信方面
3. 使用io多路复用的方式。



### 5.过期策略和内存淘汰机制

1. 过期策略

   定时删除，每隔固定的秒数，就随机取出部分的过期的键删除

   惰性删除，当取value的时候，发现已经过期了就进行删除。

2. 内存淘汰机制

   | 策略            | 描述                                                 |
   | --------------- | ---------------------------------------------------- |
   | volatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
   | volatile-ttl    | 从已设置过期时间的数据集中挑选将要过期的数据淘汰     |
   | volatile-random | 从已设置过期时间的数据集中任意选择数据淘汰           |
   | allkeys-lru     | 从所有数据集中挑选最近最少使用的数据淘汰             |
   | allkeys-random  | 从所有数据集中任意选择数据进行淘汰                   |
   | noeviction      | 禁止驱逐数据                                         |



## 设计模式

https://www.zhihu.com/question/308850392/answer/1324509357

### 工厂模式

将获得一个类的方法封装进factory中，得到该类不需要用到细节的代码，调用工厂的接口即可。

spring就类似于一个大工厂



### 单例模式

某个对象全局只需要一个实例时，就可以使用单例模式。

分为饿汉模式和懒汉模式，饿汉是指一开始就将对象初始化，而懒汉是在要使用的时候才初始化。

spring中的bean的创建就是单例，因为只创建一个。

```java
public class Single {
    private Single() {}
    饿汉模式
    private static Single mySingle = new Single();

    public static Single getInstance() {
        return mySingle;
    }

    懒汉模式 有线程安全问题
    private static Single mySingle = null;

    public static Single getInstance() {
        if (mySingle == null) {
            mySingle = new Single();
        }
        return mySingle;
    }

    懒汉模式 通过synchronized来加锁
    private static Single mySingle = null;

    public synchronized static Single getInstance() {
        if (mySingle == null) {
            mySingle = new Single();
        }
        return mySingle;
    }

    懒汉模式 减小锁的粒度
    private static Single mySingle = null;

    public static Single getInstance() {
        if (mySingle == null) {
            synchronized(Single.class) {
                if (mySingle == null) {
                    mySingle = new Single();
                }
            }
        }
        return mySingle;
    }
    内部类形式
    private static class SingleHolder {
        private static Single mySingle = new Single();
    }

    public static Single getInstance() {
        return SingleHolder.mySingle;
    }

}
```



### 建造者模式

类似于.build()的方法，将一系列的配置写出来，保证不会忘记配置。



### 代理模式

就是在使用的和被代理类同样的功能的同时，可以加入自己的控制的地方，比如权限控制。

分为静态代理和动态代理，动态代理使用反射来获得method的调用。



## Spring

### 1.spring MVC过程

![](https://img-blog.csdn.net/20180708224853769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NDUyMzM3MDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



### 2.Spring Aop jdk代理和cglib代理

JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑贬值在一起。

JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理实例哪？答案就是CGLib。

CGLib采用底层的字节码技术，全称是：Code Generation Library，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。



https://blog.nowcoder.net/n/ba0c0cd19cf447d3a4c34c449cbc72c5

https://www.nowcoder.com/discuss/405908?type=post&order=time&pos=&page=2&channel=1009&source_id=search_post

[topK](https://blog.csdn.net/v_july_v/article/details/7382693)



## GoLang

### 1.数组和切片

https://www.cnblogs.com/liuzhongchao/p/9159896.html

https://www.cnblogs.com/zhangboyu/p/7623712.html

引用是实际传入，数组是复制



### 2.变量

在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。

```Go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```

f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量`*y`将是不可达的，也就是说可以马上被回收的。因此，`*y`并没有从函数g中逃逸，编译器可以选择在栈上分配`*y`的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。



### 3.指针和接口

------

接口的另一个微妙之处是接口定义没有规定一个实现者是否应该使用一个指针接收器或一个值接收器来实现接口。当给定一个接口值时，不能保证底层类型是否为指针。在前面的示例中，我们将方法定义在值接收者之上。让我们稍微改变一下，将 `Cat` 的 `Speak()` 方法改为指针接收器：

```go
func (c *Cat) Speak() string {return "Meow!"}
```

运行上述代码，会得到如下错误：

```
cannot use Cat literal (``type` `Cat) as ``type` `Animal in array or slice literal:``  ``Cat does not implement Animal (Speak method has pointer receiver)
```

该错误的意思是：你尝试将 `Cat` 转为 `Animal` ，但是只有 `*Cat` 类型实现了该接口。你可以通过传入一个指针 （`new(Cat)` 或者 `&Cat{}`）来修复这个错误。

```go
animals := []Animal{Dog{}, new(Cat), Llama{}, JavaProgrammer{}}
```

让我们做一些相反的事情：我们传入一个 `*Dog` 指针，但是不改变 `Dog` 的 `Speak()` 方法：

```
animals := []Animal{new(Dog), new(Cat), Llama{}, JavaProgrammer{}}
```

这种方式可正常工作，**因为一个指针类型可以通过其相关的值类型来访问值类型的方法，但是反过来不行。**即，一个 `*Dog` 类型的值可以使用定义在 `Dog` 类型上的 `Speak()` 方法，而 `Cat` 类型的值不能访问定义在 `*Cat` 类型上的方法。

这可能听起来很神秘，但当你记住以下内容时就清楚了：**Go 中的所有东西都是按值传递的。每次调用函数时，传入的数据都会被复制。对于具有值接收者的方法，在调用该方法时将复制该值。**例如下面的方法：

```
func` `(t T)MyMethod(s string) {``  ``// ...``}　
```

是 `func(T, string)` 类型的方法。方法接收器像其他参数一样通过值传递给函数。

因为所有的参数都是通过值传递的，这就可以解释为什么 `*Cat` 的方法不能被 `Cat` 类型的值调用了。任何一个 `Cat` 类型的值可能会有很多 `*Cat` 类型的指针指向它，如果我们尝试通过 `Cat` 类型的值来调用 `*Cat` 的方法，根本就不知道对应的是哪个指针。相反，如果 `Dog` 类型上有一个方法，通过 `*Dog` 来调用这个方法可以确切的找到该指针对应的 `Gog` 类型的值，从而调用上面的方法。运行时，Go 会自动帮我们做这些，所以我们不需要像 C语言中那样使用类似如下的语句 `d->Speak()` 。



接收的一般是指针是因为如果是一个值的话，不能够修改struct的内部的字段，指针的话可以修改。





