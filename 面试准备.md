[TOC]



##### C++基础

###### 1.引用和指针的区别

在C和C++中，指针一般指的是某块内存的**地址**，通过这个地址，我们可以寻址到这块内存；而引用是一个变量的**别名**，例如我们给小明起了个外号：明明，那我们说明明的时候，就是说小明。

对于指针来说，它是一个地址，这个地址是一个数值，那么就意味这个数值可以为0(空指针)，也可以为其他，即指针可以不指向任何东西。

而对于引用来说，他是一个外号，外号一定是“某个存在物体”的外号，所以引用不能为空，即不能存在空引用。

根据以上可知指针和引用的一个重要不同：**指针可以为空，引用不能为空。**这就意味着我们拿到一个引用的时候，是不需要判断引用是否为空的，而拿到一个指针的时候，我们则需要判断它是否为空。这点经常在判断函数参数是否有效的时候使用。
例如：

```cpp
void fun1(int *point)
{
     // 为了代码的稳健和安全，我们需要判断指针是否有效,通常做法是判断指针是否为
     // 空，其他的判断就需要根据函数的具体功能来判断了
     if(!point)
     {
        return;
     }
     // 函数实现
}

void fun2(int &refence)
{
     // 在这里，我们就不用担心refence是否为空
}
```


引用修饰函数参数还可以提高效率，例子如下：

```cpp
Class Object
{// 实现省略，只需要知道我们在这里声明了一个类，在下面我们要将这个类的对象作为
 // 函数参数类型来使用};
void fun1(Object obj)
{
     // 此函数声明中，obj是值传递，会产生一个临时对象
}
void fun2(Object &obj)
{
    // 我们不用检查obj是否为空，同时，使用引用传递，可以避免临时对象
}
```


我们根据前面的描述，还可以知道指针可以多次赋值，即在某时刻可以指向地址1，换个时候可以指向地址2，例如：

```cpp
int a = 0;
int b = 1;
int *point = NULL;
point = &a;     // 在某个时刻，指针可以指向a
point = &b;     // 换个时刻，指针可以指向b
```


而引用则不同，引用只能在初始化的时候就赋好值，之后就不能改变了，用外号的例子来说就是"明明"这个外号在出现的时候就是代指小明，之后“明明”这个外号就绑在小明身上了，它不能过段时间换成小暗的外号。代码如下：

```cpp
int xiaoming = 1;
int &refence_mingming = xiaoming;
int xiaoan = 2;
refence_mingming = xiaoan;           // error,引用不能换了
```



由以上可以，当我们需要某个是否指向为空的时候，我们就需要使用指针了，还有指向的对象需要变化的时候，我们也需要使用指针。其他地方一般推荐引用。

const修饰引用，使得引用不能够进行值的变化。

const修饰指针，有两种区别

```cpp
	int t = 10;
	int* const p = &t;
	int t1 = 11;
	p = &t1;//error
```

```cpp
    int t = 10;
	const int* p = &t;
	int t1 = 11;
	p = &t1;//true
```



###### 2.new delete malloc free

malloc/free 

用来分配内存和释放内存。

new/delete

1. new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
3. new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。



###### 3.vector和list的区别

vector为存储的对象分配一块连续的地址空间，因此对vector中的元素随机访问效率很高。在vector中插入或者删除某个元素，需要将现有元素进行复制，移动。如果vector中存储的对象很大，或者构造函数复杂，则在对现有元素进行拷贝时开销较大，因为拷贝对象要调用拷贝构造函数。对于简单的小对象，vector的效率优于list。vector在每次扩张容量的时候，将容量扩展2倍，这样对于小对象来说，效率是很高的。

list中的对象是**离散存储**的，随机访问某个元素需要遍历list。在list中插入元素，尤其是在首尾插入元素，效率很高，只需要改变元素的指针。



###### 4.vector的内存分配机制

vector所有的内存相关问题都可以归结于它的内存增长策略。vector有一个特点就是：内存空间只会增长不会减少。vector有两个函数，一个是capacity()，返回对象缓冲区（vector维护的内存空间）实际申请的空间大小，另一个size()，返回当前对象缓冲区存储数据的个数。对于vector来说，capacity是永远大于等于size的，当capacity和size相等时，vector就会扩容，capacity变大。

比如说vector最常用的push_back操作，它的整个过程是怎么一个机制呢？这个问题经常在面试中出现。

这个问题其实很简单，在调用push_back时，若当前容量已经不能够放入新的元素（capacity=size），那么vector会重新申请一块内存，把之前的内存里的元素拷贝到新的内存当中，然后把push_back的元素拷贝到新的内存中，最后要析构原有的vector并释放原有的内存。所以说这个过程的效率是极低的，为了避免频繁的分配内存，C++每次申请内存都会成倍的增长，例如之前是4，那么重新申请后就是8，以此类推。



###### 5.set map

set和map内部都是使用红黑树进行实现  log(n)

加了unordered修饰的都是O(1)



###### 6.虚函数

函数重载一般是指多个函数共用一个名字，用不同传递参数的方式来实现多态。

而在父类和子类之间，两个类中有不同的函数实现而函数名相同的函数时就会出现问题，子类函数在逻辑上虽然会继承父类的函数，但是两个函数并不能通过不同的参数传递方式来进行区分(会报错)。而且在使用指针指向类时，父类指针指向子类实体时，调用的还是父类的函数实现。

这是需要通过加上virtual来实现继承中的函数多态。

```cpp
#include<bits/stdc++.h>
using namespace std;

class A{
	public:
		void cal(){
			cout<<"A cal"<<endl;
		}
}; 

class B:public A{
	public:
		void cal1(){
			cout<<"B cal"<<endl;
		}
};

int main(){
	A *b = new B();
	b->cal();
	return 0;
}
```

这里使用A类指针指向B类实体，调用的cal()函数是A类的。



**虚析构函数**，如果不加virtual的话，那么在类的析构函数的调用需要根据指针来进行判断，如果是父类的指针，那么可能少析构子类中的内存。

```cpp
#include <iostream>
using namespace std;
 
class Base
{
private:
	int i;
public :
	Base()
	{
		cout << "Base count " << endl;
	}
	 ~Base()
	{ 
		
		cout << " Base descount" << endl;
	}
};
class Inherit :public Base
{
private:
	int num;
public: 
	Inherit()
	{
		cout << "Inherit count" << endl;
	}
	 ~Inherit()  
	{
		cout << "Inherit descout" << endl;
		
	}
};
int main()
{
	Base *p =  new Inherit();
	delete p;
	Base *q = new Base();
	delete q;
	return 0;
}
```

此时第一个p就只会析构父类中的内存，而不会调用子类的析构函数。

讲虚函数表的文章: https://blog.twofei.com/496/



**虚继承**

避免菱形继承问题

```cpp
class A    // 声明基类A
{
    // 代码
};
class B: virtual public A    // 声明类 B 是类 A 的公有派生类，A 是 B 的虚基类
{
    // 代码
};
class C: virtual public A    // 声明类 C 是类 A 的公有派生类，A 是 C 的虚基类
{
    // 代码
};
class D: public B, public C    // 类 D 中只有一份 A 的数据
{
    // 代码
};
```



###### 7.完全背包的推导

```cpp
# dp[i][j] 使用前i种硬币计算j分的表示法种数 令coins=[25, 10, 5, 1]
# dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
# j >= k*coins[i]
# dp[i][j-coins[i]] = dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
# dp[i][j] - dp[i][j-coins[i]] = dp[i-1][j]
# dp[i][j] = dp[i][j-coins[i]] + dp[i-1][j]

dp[j] = dp[j]+dp[j-coins[i]];
```

从0开始更新第i个的状态。已经更新的为f(i,j-coins[i]),加上本身还没有更新的自己f(i-1,j);



###### 8.左闭右开的写法

二分查找中写成左闭右开，主要看left的操作，left为可以取到的，而二分查找尽量写成都越过mid，即都不取到mid。最后l==r，表示将整个空间都搜索完全。

而搜索中写成左闭右开需要考虑到只剩下一个元素时即返回。所以一般为l+1 >= r时return。

双指针写法时不考虑这些。

https://www.luogu.com.cn/blog/HOJQVFNA/qian-tan-er-fen-di-bian-jie-wen-ti

##### Java基础学习   

###### 1.HashMap源码分析

https://juejin.im/post/6844903799748821000




##### 计算机网络

###### 1.http和https的区别

https过程：

1. 首先是客户端向服务端发送请求；
2. 服务端向客户端发送自己的ssl证书；
3. 客户端验证证书后，得到证书中的公钥，之后生成对称加密算法所需要的密钥和算法，用公钥加密后发送给客服务端；
4. 服务端获得信息后，使用自己的私钥进行解密，得到对称密钥和算法，之后发送信息时使用对称加密的方式进行交流。



http 端口为80 https端口为443



HTTPS和HTTP的区别主要如下：

1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包（具体可查看马海祥博客《[HTTP服务的七层架构技术解析及运用](http://www.mahaixiang.cn/internet/801.html)》的相关介绍）；HTTPS除了TCP的三个包，还要加上ssl握手需要的9个包，所以一共是12个包。



缺点 ：加载速度慢，且费用较高



###### 2.数据链路层

![image-20200323172500056](.\pic\image-20200323172500056.png)

差错检测：CRC，校验和 

差错控制：回退N协议，选择性重传

介质访问控制：广播信道：CSMA/CD，信道复用 

​                           点对点信道：PPP协议 MAC地址

​                           以太网 透明网桥 VLAN



###### 3.网络层

和IP相关的协议。

ARP协议 通过询问IP地址得知MAC地址

DHCP协议 客户端在加入网络的时候 租用IP地址

ICMP协议  消息控制协议



和路由器相关的协议

RIP协议  

OSPF协议

BGP协议



###### 4.传输层

![image-20200328075224512](.\pic\image-20200328075224512.png)

![image-20200328075244121](.\pic\image-20200328075244121.png)

TCP拥塞控制：

慢开始：从1开始，每次加倍，过了阈值，开始每次加1。超时之后，发生拥塞，重新开始，并且阈值设为现在的一半。

 拥塞避免 快重传 快恢复



###### 5.对称加密和非对称加密

对称加密只需要公钥，被黑客拦截不安全

非对称加密既有公钥又有私钥。

![image-20200330154408649](.\pic\image-20200330154408649.png)

由于纯粹的非对称加密比较的慢，所以一般是非对称和对称加密一起使用。类似于https的开始环节。

但这里需要注意“中间人攻击”，发送公钥的时候，被中间人截取，假装为A要通信的B，发回一个用A公钥进行加密后的key，中间人再和B发送自己的公钥，进行加密连接。这样依然可以获取明文，被攻击。所以https加上了一个认证的证书。





###### 6.TCP的三次握手

①服务端创建传输控制块TCB，进入LISTEN状态，准备接收客户端的请求。客户端同样先创建TCB，然后当准备建立连接时向服务端发送连接请求报文（SYN=1，seq=x），然后进入SYN-SENT状态。②服务端收到后向客户端发送确认报文（SYN=1，ACK=1，ack=x+1，seq=y），进入SYN-RCVD状态。③客户端接收到确认后，再向服务端发送一个确认报文（ACK=1，ack=y+1，seq=x+1），然后进入ESTABLISHED状态，服务端接收后也进入ESTABLISHED状态。
④不是两次的原因是为了避免无效的连接请求突然发送到服务端，而此时客户端已关闭，服务端误以为客户端将要发送数据会白白浪费资源。⑤不是四次的原因是将服务端的SYN和ACK报文拆分成两次发送和一次的效果是相同的，没有意义。



###### 7.TCP的四次挥手过程

①当客户端准备关闭连接时，向服务端发送连接终止报文（FIN=1，seq=u），进入FIN-WAIT-1状态。②服务端接收后向客户端发送确认报文（ACK=1，ack=u+1，seq=v），进入CLOSE-WAIT状态，客户端收到后进入FIN-WAIT-2状态，此时TCP连接处于半关闭状态。③当服务端也发送完全部数据准备断开连接时，向客户发送连接终止报文（FIN=1，ACK=1，ack=u+1，seq=w），进入LAST-ACK状态。④客户端接收到该报文后，发送一个确认报文（ACK=w+1，ack=1，seq=u+1），进入TIME-WAIT状态，然后等待2MSL时间后关闭。服务端收到后关闭，时间将略早于客户端。⑤不是三次的原因第一是为了保证客户端发送的最后一个报文可以到达服务端，如果该报文丢失那么服务端会超时重传之前的FIN+ACK报文，客户端可以在2MSL内收到，第二是防止已失效的报文发送到客户端，在2MSL后客户端在本连接时间内发出的所有报文都将从网络中消失。

客户端发起关闭请求后，服务器端可能还有数据要继续发送没有发送完，所以先发送ACK，表示答应让客户端继续等待消息，之后在确保发送数据完成后，发送自己的关闭请求。



###### 8.Http的传输过程

①地址解析：地址解析通过域名系统DNS解析服务器域名从而获得主机的IP地址。例如客户端的浏览器请求http://localhost:8080/index.html，则可分析出：协议名HTTP、主机名localhost、端口8080、对象路径/index.html。②封装HTTP数据包：解析协议名、主机名、端口、对象路径等并结合本机自己的信息封装成一个HTTP请求数据包。③封装TCP包：将HTTP请求数据包进一步封装成TCP数据包。④建立TCP连接：基于TCP的三次握手机制建立TCP连接。⑤客户端发送请求：在建立连接后，客户端发送一个请求给服务器。⑥服务器响应：服务器在接收到请求后，结合业务逻辑进行数据处理，然后向客户端返回相应的响应信息。在响应信息中包含状态行、协议版本号、成功或错误的代码、消息体等内容。⑦服务器关闭TCP连接：服务器在向浏览器发送请求响应数据后关闭TCP连接。但如果浏览器或者服务器在消息头加入了Connection : keep-alive，则TCP连接在请求响应数据后仍然保持连接状态，在下一次请求中浏览器可以继续使用相同的连接发送请求。采用keep-alive不但减少了请求响应的时间，还节约了网络带宽和系统资源。




##### 操作系统

###### 1.进程和线程

- 一个进程中至少有一个线程运行，可以有多个线程

- 不同进程间数据共享困难，而同一进程下的线程数据共享容易
- 进程切换需要保存的数据量多，上下文环境复杂，线程的切换容易，保存少量寄存器。

线程安全问题：

多个线程并发运行的环境下，多个线程访问同一个共享的内存资源时，不同线程的读写问题。例如，一个线程读之后，还没有完成写操作的时候，另一个线程也进行了读，读取的是之前的数据，而非已经改过的数据，造成资源出错。类似于生产者消费者问题。





###### 2.并发和并行

并行是多个内核同一时间运行不同的线程，而并发是利用cpu调度来实现线程的同时运行。



###### 3.进程调度算法

批处理系统：

1.先来先服务

2.短作业优先

3.最短剩余时间优先

交互式系统：

1.时间片轮转

2.优先级调度

3.多级反馈队列



###### 4.死锁

死锁一般具有四个特性：

1.互斥条件：只有一把钥匙

2.请求与保持条件：拿着红钥匙的人在没有归还红钥匙的情况下，又提出要蓝钥匙

3.不剥夺条件:人除非归还了钥匙，不然一直占用着钥匙

4.环路等待条件：拿着红钥匙的人在等蓝钥匙，同时那个拿着蓝钥匙的人在等红钥匙

破坏死锁的条件一般就是破坏其中一种条件即可。



###### 5.虚存技术

分页见计算机组成原理的地方。 

分段。



###### 6.生产者消费者问题

```text
mutex = 1
empty = n
full = 0

void producer(){
     p(empty)
     p(mutex)
     insert_item()
     v(mutex)
     v(full)
}

void customer(){
     p(full)
     p(mutex)
     delete_item()
     v(mutex)
     v(empty)
}
```

两个p操作不能够进行交换：假设交换之后，首先将缓冲区进行锁定，如果当前已经没有剩余的空间的话，那么就会将进程挂起，而如果生产者进程挂起的话，消费者进程不能够进入那么就会死锁。



###### 7.同步和异步

这个概念针对的是**消息通信机制**，同步的话，需要自己去查询函数是否已经完成，而异步的话，是函数自己告诉你是否完成。



###### 8.进程间通信

两个机器间可以通过socket来进行进程间的通信。



##### 计算机组成原理

###### 1.CPU工作过程

![image-20200427092756498](.\pic\image-20200427092756498.png)

取出程序计数器中指向的指令放进指令寄存器中，根据指令取出数据或是操作数据，得到结果。



###### 2.Cache

是放在CPU和内存之间的缓存。CPU中放有寄存器速度快于Cache，Cache速度快于内存。SRAM。



###### 3.虚存分页技术

![img](http://c.biancheng.net/cpp/uploads/allimg/140701/1-140F102004L08.jpg)

页表在内存中，TLB是Cache。MMU内存管理单元，用来转换逻辑地址为物理地址。

先将逻辑地址mod页面的大小，得到虚拟的页号，通过上述图片的过程找到对应的物理页号，然后加上偏移量来得到物理地址。



##### 数据库

###### **[mysql详解](https://juejin.im/post/6850037271233331208#heading-35)**

###### 1.B树和B+树的区别

1.单一节点存储的元素更多，使得查询的IO次数更少，所以适合作为MySQL的底层数据结构。

2.所有的查询都要查找叶子节点，查询性能更加稳定，而B树每一个节点都可以查找到数据，所以不稳定。

3.所有的叶子节点形成有序链表，更加便于查询。



###### 2.数据库范式

https://www.cnblogs.com/wsg25/p/9615100.html

第一范式：**要求数据库表的每一列都是不可分割的原子数据项。**

第二范式：**第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关**

第三范式：**第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**



###### 3.数据库的隔离级别

未提交读 已提交读 可重复读 可串行化



###### 4.隔离性问题

脏读 不可重复读 幻读

![image-20200808175214680](.\pic\image-20200808175214680.png)

![image-20200808175245158](.\pic\image-20200808175245158.png)

![image-20200808175229534](.\pic\image-20200808175229534.png)

脏读：事务读取到另一个事务还没有提交的事务，如果发生回滚读到的数据就为脏数据。

不可重复读：一个事务前后两次读，数据不一样。

幻读：前后两次读，数据的数量不同。



###### 5.索引

聚集索引：主键，变成了b+树(平衡树)结构，方便进行查询。

![img](https://pic1.zhimg.com/v2-2ce9fa4e6d645ed4f105b8334fc2c488_b.jpg)

非聚集索引：通过非主键的部分建立，建立新的索引。查询时通过索引查询到主键的id再在主键建立的索引上进行查询。

![img](https://pic4.zhimg.com/v2-fbb0e0b277cc1177d2e76518793f99cf_b.jpg)

通过建立索引，使得查询加快，但是会使得存储之类的操作变慢，因为要维护一个树形的结构。

**MYSQL最左前缀匹配原则**

关于最左前缀的使用，有下面两条说明：

- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

单独只用一个b=2的话会采用index匹配的索引

![image-20200421103800858](.\pic\image-20200421103800858.png)

一般正常能够加快搜索的索引都是type为**ref**的索引。



###### 6.表的连接

inner join，left join，right join ,全外连接



###### 7.ACID

原子性，隔离性，持久性，一致性。

原子性：一个事务要么都完成，要么都不做

隔离性：事务之间互不影响

持久性：数据库发生故障也不会对已经提交的数据有影响

一致性：事务前后状态一致，状态正确。



###### 8.X/S锁

X：事务对资源A进行上锁后，既能对他读又能对他写，但是其他的事务不能够进行加锁。

S：事务对资源上锁后，只能对他读不能对他写，其他的事务也只能够对他进行加S锁。


